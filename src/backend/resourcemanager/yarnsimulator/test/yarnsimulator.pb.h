// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: yarnsimulator.proto

#ifndef PROTOBUF_yarnsimulator_2eproto__INCLUDED
#define PROTOBUF_yarnsimulator_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_yarnsimulator_2eproto();
void protobuf_AssignDesc_yarnsimulator_2eproto();
void protobuf_ShutdownFile_yarnsimulator_2eproto();

class JobContextProto;
class ResourceProto;
class ResourceGroupProto;
class NodeReportProto;
class ClusterReportProto;
class NodeResourceProto;
class ClusterResourceProto;
class CreateJobRequestProto;
class CreateJobResponseProto;
class FinishJobRequestProto;
class FinishJobResponseProto;
class AllocateResourcesRequestProto;
class AllocateResourcesResponseProto;
class ActiveResourcesRequestProto;
class ActiveResourcesResponseProto;
class ReleaseResourcesRequestProto;
class ReleaseResourcesResponseProto;
class GetClusterReportRequestProto;
class GetClusterReportResponseProto;
class GetClusterResourceRequestProto;
class GetClusterResourceResponseProto;

enum NodeStateProto {
  NEW = 1,
  DECOMMISSIONED = 4,
  LOST = 5,
  REBOOTED = 6
};
bool NodeStateProto_IsValid(int value);
const NodeStateProto NodeStateProto_MIN = NEW;
const NodeStateProto NodeStateProto_MAX = REBOOTED;
const int NodeStateProto_ARRAYSIZE = NodeStateProto_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeStateProto_descriptor();
inline const ::std::string& NodeStateProto_Name(NodeStateProto value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeStateProto_descriptor(), value);
}
inline bool NodeStateProto_Parse(
    const ::std::string& name, NodeStateProto* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStateProto>(
    NodeStateProto_descriptor(), name, value);
}
// ===================================================================

class JobContextProto : public ::google::protobuf::Message {
 public:
  JobContextProto();
  virtual ~JobContextProto();

  JobContextProto(const JobContextProto& from);

  inline JobContextProto& operator=(const JobContextProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobContextProto& default_instance();

  void Swap(JobContextProto* other);

  // implements Message ----------------------------------------------

  JobContextProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobContextProto& from);
  void MergeFrom(const JobContextProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string jobId = 1;
  inline bool has_jobid() const;
  inline void clear_jobid();
  static const int kJobIdFieldNumber = 1;
  inline const ::std::string& jobid() const;
  inline void set_jobid(const ::std::string& value);
  inline void set_jobid(const char* value);
  inline void set_jobid(const char* value, size_t size);
  inline ::std::string* mutable_jobid();
  inline ::std::string* release_jobid();
  inline void set_allocated_jobid(::std::string* jobid);

  // optional string jobName = 2;
  inline bool has_jobname() const;
  inline void clear_jobname();
  static const int kJobNameFieldNumber = 2;
  inline const ::std::string& jobname() const;
  inline void set_jobname(const ::std::string& value);
  inline void set_jobname(const char* value);
  inline void set_jobname(const char* value, size_t size);
  inline ::std::string* mutable_jobname();
  inline ::std::string* release_jobname();
  inline void set_allocated_jobname(::std::string* jobname);

  // optional string queue = 3;
  inline bool has_queue() const;
  inline void clear_queue();
  static const int kQueueFieldNumber = 3;
  inline const ::std::string& queue() const;
  inline void set_queue(const ::std::string& value);
  inline void set_queue(const char* value);
  inline void set_queue(const char* value, size_t size);
  inline ::std::string* mutable_queue();
  inline ::std::string* release_queue();
  inline void set_allocated_queue(::std::string* queue);

  // optional string status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:JobContextProto)
 private:
  inline void set_has_jobid();
  inline void clear_has_jobid();
  inline void set_has_jobname();
  inline void clear_has_jobname();
  inline void set_has_queue();
  inline void clear_has_queue();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jobid_;
  ::std::string* jobname_;
  ::std::string* queue_;
  ::std::string* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static JobContextProto* default_instance_;
};
// -------------------------------------------------------------------

class ResourceProto : public ::google::protobuf::Message {
 public:
  ResourceProto();
  virtual ~ResourceProto();

  ResourceProto(const ResourceProto& from);

  inline ResourceProto& operator=(const ResourceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceProto& default_instance();

  void Swap(ResourceProto* other);

  // implements Message ----------------------------------------------

  ResourceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceProto& from);
  void MergeFrom(const ResourceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string hostname = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 memory = 3;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 3;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);

  // optional int32 cpu = 4;
  inline bool has_cpu() const;
  inline void clear_cpu();
  static const int kCpuFieldNumber = 4;
  inline ::google::protobuf::int32 cpu() const;
  inline void set_cpu(::google::protobuf::int32 value);

  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ResourceProto)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_cpu();
  inline void clear_has_cpu();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* hostname_;
  ::google::protobuf::int32 memory_;
  ::google::protobuf::int32 cpu_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ResourceProto* default_instance_;
};
// -------------------------------------------------------------------

class ResourceGroupProto : public ::google::protobuf::Message {
 public:
  ResourceGroupProto();
  virtual ~ResourceGroupProto();

  ResourceGroupProto(const ResourceGroupProto& from);

  inline ResourceGroupProto& operator=(const ResourceGroupProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceGroupProto& default_instance();

  void Swap(ResourceGroupProto* other);

  // implements Message ----------------------------------------------

  ResourceGroupProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceGroupProto& from);
  void MergeFrom(const ResourceGroupProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string groupId = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 1;
  inline const ::std::string& groupid() const;
  inline void set_groupid(const ::std::string& value);
  inline void set_groupid(const char* value);
  inline void set_groupid(const char* value, size_t size);
  inline ::std::string* mutable_groupid();
  inline ::std::string* release_groupid();
  inline void set_allocated_groupid(::std::string* groupid);

  // repeated .ResourceProto resources = 2;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 2;
  inline const ::ResourceProto& resources(int index) const;
  inline ::ResourceProto* mutable_resources(int index);
  inline ::ResourceProto* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::ResourceProto >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::ResourceProto >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:ResourceGroupProto)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* groupid_;
  ::google::protobuf::RepeatedPtrField< ::ResourceProto > resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ResourceGroupProto* default_instance_;
};
// -------------------------------------------------------------------

class NodeReportProto : public ::google::protobuf::Message {
 public:
  NodeReportProto();
  virtual ~NodeReportProto();

  NodeReportProto(const NodeReportProto& from);

  inline NodeReportProto& operator=(const NodeReportProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeReportProto& default_instance();

  void Swap(NodeReportProto* other);

  // implements Message ----------------------------------------------

  NodeReportProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeReportProto& from);
  void MergeFrom(const NodeReportProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required string state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // required string rack = 3;
  inline bool has_rack() const;
  inline void clear_rack();
  static const int kRackFieldNumber = 3;
  inline const ::std::string& rack() const;
  inline void set_rack(const ::std::string& value);
  inline void set_rack(const char* value);
  inline void set_rack(const char* value, size_t size);
  inline ::std::string* mutable_rack();
  inline ::std::string* release_rack();
  inline void set_allocated_rack(::std::string* rack);

  // required int32 container_num = 4;
  inline bool has_container_num() const;
  inline void clear_container_num();
  static const int kContainerNumFieldNumber = 4;
  inline ::google::protobuf::int32 container_num() const;
  inline void set_container_num(::google::protobuf::int32 value);

  // required int32 memory = 5;
  inline bool has_memory() const;
  inline void clear_memory();
  static const int kMemoryFieldNumber = 5;
  inline ::google::protobuf::int32 memory() const;
  inline void set_memory(::google::protobuf::int32 value);

  // required int32 cpu = 6;
  inline bool has_cpu() const;
  inline void clear_cpu();
  static const int kCpuFieldNumber = 6;
  inline ::google::protobuf::int32 cpu() const;
  inline void set_cpu(::google::protobuf::int32 value);

  // required string healthReport = 7;
  inline bool has_healthreport() const;
  inline void clear_healthreport();
  static const int kHealthReportFieldNumber = 7;
  inline const ::std::string& healthreport() const;
  inline void set_healthreport(const ::std::string& value);
  inline void set_healthreport(const char* value);
  inline void set_healthreport(const char* value, size_t size);
  inline ::std::string* mutable_healthreport();
  inline ::std::string* release_healthreport();
  inline void set_allocated_healthreport(::std::string* healthreport);

  // required string lastHealthReportTime = 8;
  inline bool has_lasthealthreporttime() const;
  inline void clear_lasthealthreporttime();
  static const int kLastHealthReportTimeFieldNumber = 8;
  inline const ::std::string& lasthealthreporttime() const;
  inline void set_lasthealthreporttime(const ::std::string& value);
  inline void set_lasthealthreporttime(const char* value);
  inline void set_lasthealthreporttime(const char* value, size_t size);
  inline ::std::string* mutable_lasthealthreporttime();
  inline ::std::string* release_lasthealthreporttime();
  inline void set_allocated_lasthealthreporttime(::std::string* lasthealthreporttime);

  // @@protoc_insertion_point(class_scope:NodeReportProto)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_rack();
  inline void clear_has_rack();
  inline void set_has_container_num();
  inline void clear_has_container_num();
  inline void set_has_memory();
  inline void clear_has_memory();
  inline void set_has_cpu();
  inline void clear_has_cpu();
  inline void set_has_healthreport();
  inline void clear_has_healthreport();
  inline void set_has_lasthealthreporttime();
  inline void clear_has_lasthealthreporttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::std::string* state_;
  ::std::string* rack_;
  ::google::protobuf::int32 container_num_;
  ::google::protobuf::int32 memory_;
  ::std::string* healthreport_;
  ::std::string* lasthealthreporttime_;
  ::google::protobuf::int32 cpu_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static NodeReportProto* default_instance_;
};
// -------------------------------------------------------------------

class ClusterReportProto : public ::google::protobuf::Message {
 public:
  ClusterReportProto();
  virtual ~ClusterReportProto();

  ClusterReportProto(const ClusterReportProto& from);

  inline ClusterReportProto& operator=(const ClusterReportProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterReportProto& default_instance();

  void Swap(ClusterReportProto* other);

  // implements Message ----------------------------------------------

  ClusterReportProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterReportProto& from);
  void MergeFrom(const ClusterReportProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NodeReportProto nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::NodeReportProto& nodes(int index) const;
  inline ::NodeReportProto* mutable_nodes(int index);
  inline ::NodeReportProto* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeReportProto >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeReportProto >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:ClusterReportProto)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NodeReportProto > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ClusterReportProto* default_instance_;
};
// -------------------------------------------------------------------

class NodeResourceProto : public ::google::protobuf::Message {
 public:
  NodeResourceProto();
  virtual ~NodeResourceProto();

  NodeResourceProto(const NodeResourceProto& from);

  inline NodeResourceProto& operator=(const NodeResourceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeResourceProto& default_instance();

  void Swap(NodeResourceProto* other);

  // implements Message ----------------------------------------------

  NodeResourceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeResourceProto& from);
  void MergeFrom(const NodeResourceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 min_memory = 3;
  inline bool has_min_memory() const;
  inline void clear_min_memory();
  static const int kMinMemoryFieldNumber = 3;
  inline ::google::protobuf::int32 min_memory() const;
  inline void set_min_memory(::google::protobuf::int32 value);

  // required int32 max_memory = 4;
  inline bool has_max_memory() const;
  inline void clear_max_memory();
  static const int kMaxMemoryFieldNumber = 4;
  inline ::google::protobuf::int32 max_memory() const;
  inline void set_max_memory(::google::protobuf::int32 value);

  // required int32 free_memory = 5;
  inline bool has_free_memory() const;
  inline void clear_free_memory();
  static const int kFreeMemoryFieldNumber = 5;
  inline ::google::protobuf::int32 free_memory() const;
  inline void set_free_memory(::google::protobuf::int32 value);

  // required int32 min_cpu = 6;
  inline bool has_min_cpu() const;
  inline void clear_min_cpu();
  static const int kMinCpuFieldNumber = 6;
  inline ::google::protobuf::int32 min_cpu() const;
  inline void set_min_cpu(::google::protobuf::int32 value);

  // required int32 max_cpu = 7;
  inline bool has_max_cpu() const;
  inline void clear_max_cpu();
  static const int kMaxCpuFieldNumber = 7;
  inline ::google::protobuf::int32 max_cpu() const;
  inline void set_max_cpu(::google::protobuf::int32 value);

  // required int32 free_cpu = 8;
  inline bool has_free_cpu() const;
  inline void clear_free_cpu();
  static const int kFreeCpuFieldNumber = 8;
  inline ::google::protobuf::int32 free_cpu() const;
  inline void set_free_cpu(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NodeResourceProto)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_min_memory();
  inline void clear_has_min_memory();
  inline void set_has_max_memory();
  inline void clear_has_max_memory();
  inline void set_has_free_memory();
  inline void clear_has_free_memory();
  inline void set_has_min_cpu();
  inline void clear_has_min_cpu();
  inline void set_has_max_cpu();
  inline void clear_has_max_cpu();
  inline void set_has_free_cpu();
  inline void clear_has_free_cpu();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::std::string* ip_;
  ::google::protobuf::int32 min_memory_;
  ::google::protobuf::int32 max_memory_;
  ::google::protobuf::int32 free_memory_;
  ::google::protobuf::int32 min_cpu_;
  ::google::protobuf::int32 max_cpu_;
  ::google::protobuf::int32 free_cpu_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static NodeResourceProto* default_instance_;
};
// -------------------------------------------------------------------

class ClusterResourceProto : public ::google::protobuf::Message {
 public:
  ClusterResourceProto();
  virtual ~ClusterResourceProto();

  ClusterResourceProto(const ClusterResourceProto& from);

  inline ClusterResourceProto& operator=(const ClusterResourceProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterResourceProto& default_instance();

  void Swap(ClusterResourceProto* other);

  // implements Message ----------------------------------------------

  ClusterResourceProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClusterResourceProto& from);
  void MergeFrom(const ClusterResourceProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NodeResourceProto nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::NodeResourceProto& nodes(int index) const;
  inline ::NodeResourceProto* mutable_nodes(int index);
  inline ::NodeResourceProto* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeResourceProto >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeResourceProto >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:ClusterResourceProto)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NodeResourceProto > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ClusterResourceProto* default_instance_;
};
// -------------------------------------------------------------------

class CreateJobRequestProto : public ::google::protobuf::Message {
 public:
  CreateJobRequestProto();
  virtual ~CreateJobRequestProto();

  CreateJobRequestProto(const CreateJobRequestProto& from);

  inline CreateJobRequestProto& operator=(const CreateJobRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateJobRequestProto& default_instance();

  void Swap(CreateJobRequestProto* other);

  // implements Message ----------------------------------------------

  CreateJobRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateJobRequestProto& from);
  void MergeFrom(const CreateJobRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .JobContextProto jobContext = 1;
  inline bool has_jobcontext() const;
  inline void clear_jobcontext();
  static const int kJobContextFieldNumber = 1;
  inline const ::JobContextProto& jobcontext() const;
  inline ::JobContextProto* mutable_jobcontext();
  inline ::JobContextProto* release_jobcontext();
  inline void set_allocated_jobcontext(::JobContextProto* jobcontext);

  // @@protoc_insertion_point(class_scope:CreateJobRequestProto)
 private:
  inline void set_has_jobcontext();
  inline void clear_has_jobcontext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::JobContextProto* jobcontext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static CreateJobRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class CreateJobResponseProto : public ::google::protobuf::Message {
 public:
  CreateJobResponseProto();
  virtual ~CreateJobResponseProto();

  CreateJobResponseProto(const CreateJobResponseProto& from);

  inline CreateJobResponseProto& operator=(const CreateJobResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateJobResponseProto& default_instance();

  void Swap(CreateJobResponseProto* other);

  // implements Message ----------------------------------------------

  CreateJobResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateJobResponseProto& from);
  void MergeFrom(const CreateJobResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .JobContextProto jobContext = 1;
  inline bool has_jobcontext() const;
  inline void clear_jobcontext();
  static const int kJobContextFieldNumber = 1;
  inline const ::JobContextProto& jobcontext() const;
  inline ::JobContextProto* mutable_jobcontext();
  inline ::JobContextProto* release_jobcontext();
  inline void set_allocated_jobcontext(::JobContextProto* jobcontext);

  // @@protoc_insertion_point(class_scope:CreateJobResponseProto)
 private:
  inline void set_has_jobcontext();
  inline void clear_has_jobcontext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::JobContextProto* jobcontext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static CreateJobResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class FinishJobRequestProto : public ::google::protobuf::Message {
 public:
  FinishJobRequestProto();
  virtual ~FinishJobRequestProto();

  FinishJobRequestProto(const FinishJobRequestProto& from);

  inline FinishJobRequestProto& operator=(const FinishJobRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishJobRequestProto& default_instance();

  void Swap(FinishJobRequestProto* other);

  // implements Message ----------------------------------------------

  FinishJobRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinishJobRequestProto& from);
  void MergeFrom(const FinishJobRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .JobContextProto jobContext = 1;
  inline bool has_jobcontext() const;
  inline void clear_jobcontext();
  static const int kJobContextFieldNumber = 1;
  inline const ::JobContextProto& jobcontext() const;
  inline ::JobContextProto* mutable_jobcontext();
  inline ::JobContextProto* release_jobcontext();
  inline void set_allocated_jobcontext(::JobContextProto* jobcontext);

  // @@protoc_insertion_point(class_scope:FinishJobRequestProto)
 private:
  inline void set_has_jobcontext();
  inline void clear_has_jobcontext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::JobContextProto* jobcontext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static FinishJobRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class FinishJobResponseProto : public ::google::protobuf::Message {
 public:
  FinishJobResponseProto();
  virtual ~FinishJobResponseProto();

  FinishJobResponseProto(const FinishJobResponseProto& from);

  inline FinishJobResponseProto& operator=(const FinishJobResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishJobResponseProto& default_instance();

  void Swap(FinishJobResponseProto* other);

  // implements Message ----------------------------------------------

  FinishJobResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinishJobResponseProto& from);
  void MergeFrom(const FinishJobResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .JobContextProto jobContext = 1;
  inline bool has_jobcontext() const;
  inline void clear_jobcontext();
  static const int kJobContextFieldNumber = 1;
  inline const ::JobContextProto& jobcontext() const;
  inline ::JobContextProto* mutable_jobcontext();
  inline ::JobContextProto* release_jobcontext();
  inline void set_allocated_jobcontext(::JobContextProto* jobcontext);

  // @@protoc_insertion_point(class_scope:FinishJobResponseProto)
 private:
  inline void set_has_jobcontext();
  inline void clear_has_jobcontext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::JobContextProto* jobcontext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static FinishJobResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class AllocateResourcesRequestProto : public ::google::protobuf::Message {
 public:
  AllocateResourcesRequestProto();
  virtual ~AllocateResourcesRequestProto();

  AllocateResourcesRequestProto(const AllocateResourcesRequestProto& from);

  inline AllocateResourcesRequestProto& operator=(const AllocateResourcesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocateResourcesRequestProto& default_instance();

  void Swap(AllocateResourcesRequestProto* other);

  // implements Message ----------------------------------------------

  AllocateResourcesRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllocateResourcesRequestProto& from);
  void MergeFrom(const AllocateResourcesRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string jobId = 1;
  inline bool has_jobid() const;
  inline void clear_jobid();
  static const int kJobIdFieldNumber = 1;
  inline const ::std::string& jobid() const;
  inline void set_jobid(const ::std::string& value);
  inline void set_jobid(const char* value);
  inline void set_jobid(const char* value, size_t size);
  inline ::std::string* mutable_jobid();
  inline ::std::string* release_jobid();
  inline void set_allocated_jobid(::std::string* jobid);

  // required .ResourceGroupProto resourceGroup = 2;
  inline bool has_resourcegroup() const;
  inline void clear_resourcegroup();
  static const int kResourceGroupFieldNumber = 2;
  inline const ::ResourceGroupProto& resourcegroup() const;
  inline ::ResourceGroupProto* mutable_resourcegroup();
  inline ::ResourceGroupProto* release_resourcegroup();
  inline void set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup);

  // @@protoc_insertion_point(class_scope:AllocateResourcesRequestProto)
 private:
  inline void set_has_jobid();
  inline void clear_has_jobid();
  inline void set_has_resourcegroup();
  inline void clear_has_resourcegroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jobid_;
  ::ResourceGroupProto* resourcegroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static AllocateResourcesRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class AllocateResourcesResponseProto : public ::google::protobuf::Message {
 public:
  AllocateResourcesResponseProto();
  virtual ~AllocateResourcesResponseProto();

  AllocateResourcesResponseProto(const AllocateResourcesResponseProto& from);

  inline AllocateResourcesResponseProto& operator=(const AllocateResourcesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocateResourcesResponseProto& default_instance();

  void Swap(AllocateResourcesResponseProto* other);

  // implements Message ----------------------------------------------

  AllocateResourcesResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllocateResourcesResponseProto& from);
  void MergeFrom(const AllocateResourcesResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ResourceGroupProto resourceGroup = 1;
  inline bool has_resourcegroup() const;
  inline void clear_resourcegroup();
  static const int kResourceGroupFieldNumber = 1;
  inline const ::ResourceGroupProto& resourcegroup() const;
  inline ::ResourceGroupProto* mutable_resourcegroup();
  inline ::ResourceGroupProto* release_resourcegroup();
  inline void set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup);

  // @@protoc_insertion_point(class_scope:AllocateResourcesResponseProto)
 private:
  inline void set_has_resourcegroup();
  inline void clear_has_resourcegroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ResourceGroupProto* resourcegroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static AllocateResourcesResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class ActiveResourcesRequestProto : public ::google::protobuf::Message {
 public:
  ActiveResourcesRequestProto();
  virtual ~ActiveResourcesRequestProto();

  ActiveResourcesRequestProto(const ActiveResourcesRequestProto& from);

  inline ActiveResourcesRequestProto& operator=(const ActiveResourcesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveResourcesRequestProto& default_instance();

  void Swap(ActiveResourcesRequestProto* other);

  // implements Message ----------------------------------------------

  ActiveResourcesRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActiveResourcesRequestProto& from);
  void MergeFrom(const ActiveResourcesRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string jobId = 1;
  inline bool has_jobid() const;
  inline void clear_jobid();
  static const int kJobIdFieldNumber = 1;
  inline const ::std::string& jobid() const;
  inline void set_jobid(const ::std::string& value);
  inline void set_jobid(const char* value);
  inline void set_jobid(const char* value, size_t size);
  inline ::std::string* mutable_jobid();
  inline ::std::string* release_jobid();
  inline void set_allocated_jobid(::std::string* jobid);

  // required .ResourceGroupProto resourceGroup = 2;
  inline bool has_resourcegroup() const;
  inline void clear_resourcegroup();
  static const int kResourceGroupFieldNumber = 2;
  inline const ::ResourceGroupProto& resourcegroup() const;
  inline ::ResourceGroupProto* mutable_resourcegroup();
  inline ::ResourceGroupProto* release_resourcegroup();
  inline void set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup);

  // @@protoc_insertion_point(class_scope:ActiveResourcesRequestProto)
 private:
  inline void set_has_jobid();
  inline void clear_has_jobid();
  inline void set_has_resourcegroup();
  inline void clear_has_resourcegroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jobid_;
  ::ResourceGroupProto* resourcegroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ActiveResourcesRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class ActiveResourcesResponseProto : public ::google::protobuf::Message {
 public:
  ActiveResourcesResponseProto();
  virtual ~ActiveResourcesResponseProto();

  ActiveResourcesResponseProto(const ActiveResourcesResponseProto& from);

  inline ActiveResourcesResponseProto& operator=(const ActiveResourcesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveResourcesResponseProto& default_instance();

  void Swap(ActiveResourcesResponseProto* other);

  // implements Message ----------------------------------------------

  ActiveResourcesResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActiveResourcesResponseProto& from);
  void MergeFrom(const ActiveResourcesResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ResourceGroupProto resourceGroup = 1;
  inline bool has_resourcegroup() const;
  inline void clear_resourcegroup();
  static const int kResourceGroupFieldNumber = 1;
  inline const ::ResourceGroupProto& resourcegroup() const;
  inline ::ResourceGroupProto* mutable_resourcegroup();
  inline ::ResourceGroupProto* release_resourcegroup();
  inline void set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup);

  // @@protoc_insertion_point(class_scope:ActiveResourcesResponseProto)
 private:
  inline void set_has_resourcegroup();
  inline void clear_has_resourcegroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ResourceGroupProto* resourcegroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ActiveResourcesResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class ReleaseResourcesRequestProto : public ::google::protobuf::Message {
 public:
  ReleaseResourcesRequestProto();
  virtual ~ReleaseResourcesRequestProto();

  ReleaseResourcesRequestProto(const ReleaseResourcesRequestProto& from);

  inline ReleaseResourcesRequestProto& operator=(const ReleaseResourcesRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseResourcesRequestProto& default_instance();

  void Swap(ReleaseResourcesRequestProto* other);

  // implements Message ----------------------------------------------

  ReleaseResourcesRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReleaseResourcesRequestProto& from);
  void MergeFrom(const ReleaseResourcesRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string jobId = 1;
  inline bool has_jobid() const;
  inline void clear_jobid();
  static const int kJobIdFieldNumber = 1;
  inline const ::std::string& jobid() const;
  inline void set_jobid(const ::std::string& value);
  inline void set_jobid(const char* value);
  inline void set_jobid(const char* value, size_t size);
  inline ::std::string* mutable_jobid();
  inline ::std::string* release_jobid();
  inline void set_allocated_jobid(::std::string* jobid);

  // required .ResourceGroupProto resourceGroup = 2;
  inline bool has_resourcegroup() const;
  inline void clear_resourcegroup();
  static const int kResourceGroupFieldNumber = 2;
  inline const ::ResourceGroupProto& resourcegroup() const;
  inline ::ResourceGroupProto* mutable_resourcegroup();
  inline ::ResourceGroupProto* release_resourcegroup();
  inline void set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup);

  // @@protoc_insertion_point(class_scope:ReleaseResourcesRequestProto)
 private:
  inline void set_has_jobid();
  inline void clear_has_jobid();
  inline void set_has_resourcegroup();
  inline void clear_has_resourcegroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jobid_;
  ::ResourceGroupProto* resourcegroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ReleaseResourcesRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class ReleaseResourcesResponseProto : public ::google::protobuf::Message {
 public:
  ReleaseResourcesResponseProto();
  virtual ~ReleaseResourcesResponseProto();

  ReleaseResourcesResponseProto(const ReleaseResourcesResponseProto& from);

  inline ReleaseResourcesResponseProto& operator=(const ReleaseResourcesResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseResourcesResponseProto& default_instance();

  void Swap(ReleaseResourcesResponseProto* other);

  // implements Message ----------------------------------------------

  ReleaseResourcesResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReleaseResourcesResponseProto& from);
  void MergeFrom(const ReleaseResourcesResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ResourceGroupProto resourceGroup = 1;
  inline bool has_resourcegroup() const;
  inline void clear_resourcegroup();
  static const int kResourceGroupFieldNumber = 1;
  inline const ::ResourceGroupProto& resourcegroup() const;
  inline ::ResourceGroupProto* mutable_resourcegroup();
  inline ::ResourceGroupProto* release_resourcegroup();
  inline void set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup);

  // @@protoc_insertion_point(class_scope:ReleaseResourcesResponseProto)
 private:
  inline void set_has_resourcegroup();
  inline void clear_has_resourcegroup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ResourceGroupProto* resourcegroup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static ReleaseResourcesResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterReportRequestProto : public ::google::protobuf::Message {
 public:
  GetClusterReportRequestProto();
  virtual ~GetClusterReportRequestProto();

  GetClusterReportRequestProto(const GetClusterReportRequestProto& from);

  inline GetClusterReportRequestProto& operator=(const GetClusterReportRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterReportRequestProto& default_instance();

  void Swap(GetClusterReportRequestProto* other);

  // implements Message ----------------------------------------------

  GetClusterReportRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterReportRequestProto& from);
  void MergeFrom(const GetClusterReportRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeStateProto state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::NodeStateProto state() const;
  inline void set_state(::NodeStateProto value);

  // @@protoc_insertion_point(class_scope:GetClusterReportRequestProto)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static GetClusterReportRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterReportResponseProto : public ::google::protobuf::Message {
 public:
  GetClusterReportResponseProto();
  virtual ~GetClusterReportResponseProto();

  GetClusterReportResponseProto(const GetClusterReportResponseProto& from);

  inline GetClusterReportResponseProto& operator=(const GetClusterReportResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterReportResponseProto& default_instance();

  void Swap(GetClusterReportResponseProto* other);

  // implements Message ----------------------------------------------

  GetClusterReportResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterReportResponseProto& from);
  void MergeFrom(const GetClusterReportResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ClusterReportProto report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::ClusterReportProto& report() const;
  inline ::ClusterReportProto* mutable_report();
  inline ::ClusterReportProto* release_report();
  inline void set_allocated_report(::ClusterReportProto* report);

  // @@protoc_insertion_point(class_scope:GetClusterReportResponseProto)
 private:
  inline void set_has_report();
  inline void clear_has_report();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClusterReportProto* report_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static GetClusterReportResponseProto* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterResourceRequestProto : public ::google::protobuf::Message {
 public:
  GetClusterResourceRequestProto();
  virtual ~GetClusterResourceRequestProto();

  GetClusterResourceRequestProto(const GetClusterResourceRequestProto& from);

  inline GetClusterResourceRequestProto& operator=(const GetClusterResourceRequestProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterResourceRequestProto& default_instance();

  void Swap(GetClusterResourceRequestProto* other);

  // implements Message ----------------------------------------------

  GetClusterResourceRequestProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterResourceRequestProto& from);
  void MergeFrom(const GetClusterResourceRequestProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .NodeStateProto state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::NodeStateProto state() const;
  inline void set_state(::NodeStateProto value);

  // @@protoc_insertion_point(class_scope:GetClusterResourceRequestProto)
 private:
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static GetClusterResourceRequestProto* default_instance_;
};
// -------------------------------------------------------------------

class GetClusterResourceResponseProto : public ::google::protobuf::Message {
 public:
  GetClusterResourceResponseProto();
  virtual ~GetClusterResourceResponseProto();

  GetClusterResourceResponseProto(const GetClusterResourceResponseProto& from);

  inline GetClusterResourceResponseProto& operator=(const GetClusterResourceResponseProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterResourceResponseProto& default_instance();

  void Swap(GetClusterResourceResponseProto* other);

  // implements Message ----------------------------------------------

  GetClusterResourceResponseProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetClusterResourceResponseProto& from);
  void MergeFrom(const GetClusterResourceResponseProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ClusterResourceProto resources = 1;
  inline bool has_resources() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 1;
  inline const ::ClusterResourceProto& resources() const;
  inline ::ClusterResourceProto* mutable_resources();
  inline ::ClusterResourceProto* release_resources();
  inline void set_allocated_resources(::ClusterResourceProto* resources);

  // @@protoc_insertion_point(class_scope:GetClusterResourceResponseProto)
 private:
  inline void set_has_resources();
  inline void clear_has_resources();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClusterResourceProto* resources_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_yarnsimulator_2eproto();
  friend void protobuf_AssignDesc_yarnsimulator_2eproto();
  friend void protobuf_ShutdownFile_yarnsimulator_2eproto();

  void InitAsDefaultInstance();
  static GetClusterResourceResponseProto* default_instance_;
};
// ===================================================================


// ===================================================================

// JobContextProto

// optional string jobId = 1;
inline bool JobContextProto::has_jobid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobContextProto::set_has_jobid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobContextProto::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobContextProto::clear_jobid() {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    jobid_->clear();
  }
  clear_has_jobid();
}
inline const ::std::string& JobContextProto::jobid() const {
  return *jobid_;
}
inline void JobContextProto::set_jobid(const ::std::string& value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void JobContextProto::set_jobid(const char* value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void JobContextProto::set_jobid(const char* value, size_t size) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobContextProto::mutable_jobid() {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  return jobid_;
}
inline ::std::string* JobContextProto::release_jobid() {
  clear_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobid_;
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobContextProto::set_allocated_jobid(::std::string* jobid) {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    delete jobid_;
  }
  if (jobid) {
    set_has_jobid();
    jobid_ = jobid;
  } else {
    clear_has_jobid();
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jobName = 2;
inline bool JobContextProto::has_jobname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobContextProto::set_has_jobname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobContextProto::clear_has_jobname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobContextProto::clear_jobname() {
  if (jobname_ != &::google::protobuf::internal::kEmptyString) {
    jobname_->clear();
  }
  clear_has_jobname();
}
inline const ::std::string& JobContextProto::jobname() const {
  return *jobname_;
}
inline void JobContextProto::set_jobname(const ::std::string& value) {
  set_has_jobname();
  if (jobname_ == &::google::protobuf::internal::kEmptyString) {
    jobname_ = new ::std::string;
  }
  jobname_->assign(value);
}
inline void JobContextProto::set_jobname(const char* value) {
  set_has_jobname();
  if (jobname_ == &::google::protobuf::internal::kEmptyString) {
    jobname_ = new ::std::string;
  }
  jobname_->assign(value);
}
inline void JobContextProto::set_jobname(const char* value, size_t size) {
  set_has_jobname();
  if (jobname_ == &::google::protobuf::internal::kEmptyString) {
    jobname_ = new ::std::string;
  }
  jobname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobContextProto::mutable_jobname() {
  set_has_jobname();
  if (jobname_ == &::google::protobuf::internal::kEmptyString) {
    jobname_ = new ::std::string;
  }
  return jobname_;
}
inline ::std::string* JobContextProto::release_jobname() {
  clear_has_jobname();
  if (jobname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobname_;
    jobname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobContextProto::set_allocated_jobname(::std::string* jobname) {
  if (jobname_ != &::google::protobuf::internal::kEmptyString) {
    delete jobname_;
  }
  if (jobname) {
    set_has_jobname();
    jobname_ = jobname;
  } else {
    clear_has_jobname();
    jobname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string queue = 3;
inline bool JobContextProto::has_queue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobContextProto::set_has_queue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobContextProto::clear_has_queue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobContextProto::clear_queue() {
  if (queue_ != &::google::protobuf::internal::kEmptyString) {
    queue_->clear();
  }
  clear_has_queue();
}
inline const ::std::string& JobContextProto::queue() const {
  return *queue_;
}
inline void JobContextProto::set_queue(const ::std::string& value) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(value);
}
inline void JobContextProto::set_queue(const char* value) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(value);
}
inline void JobContextProto::set_queue(const char* value, size_t size) {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  queue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobContextProto::mutable_queue() {
  set_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    queue_ = new ::std::string;
  }
  return queue_;
}
inline ::std::string* JobContextProto::release_queue() {
  clear_has_queue();
  if (queue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = queue_;
    queue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobContextProto::set_allocated_queue(::std::string* queue) {
  if (queue_ != &::google::protobuf::internal::kEmptyString) {
    delete queue_;
  }
  if (queue) {
    set_has_queue();
    queue_ = queue;
  } else {
    clear_has_queue();
    queue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string status = 4;
inline bool JobContextProto::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobContextProto::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobContextProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobContextProto::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& JobContextProto::status() const {
  return *status_;
}
inline void JobContextProto::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void JobContextProto::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void JobContextProto::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobContextProto::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* JobContextProto::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobContextProto::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResourceProto

// optional string id = 1;
inline bool ResourceProto::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceProto::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceProto::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceProto::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& ResourceProto::id() const {
  return *id_;
}
inline void ResourceProto::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ResourceProto::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void ResourceProto::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceProto::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* ResourceProto::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceProto::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hostname = 2;
inline bool ResourceProto::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceProto::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceProto::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceProto::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ResourceProto::hostname() const {
  return *hostname_;
}
inline void ResourceProto::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ResourceProto::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ResourceProto::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceProto::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* ResourceProto::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceProto::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 memory = 3;
inline bool ResourceProto::has_memory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceProto::set_has_memory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceProto::clear_has_memory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceProto::clear_memory() {
  memory_ = 0;
  clear_has_memory();
}
inline ::google::protobuf::int32 ResourceProto::memory() const {
  return memory_;
}
inline void ResourceProto::set_memory(::google::protobuf::int32 value) {
  set_has_memory();
  memory_ = value;
}

// optional int32 cpu = 4;
inline bool ResourceProto::has_cpu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceProto::set_has_cpu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceProto::clear_has_cpu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceProto::clear_cpu() {
  cpu_ = 0;
  clear_has_cpu();
}
inline ::google::protobuf::int32 ResourceProto::cpu() const {
  return cpu_;
}
inline void ResourceProto::set_cpu(::google::protobuf::int32 value) {
  set_has_cpu();
  cpu_ = value;
}

// optional int32 status = 5;
inline bool ResourceProto::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceProto::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceProto::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceProto::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ResourceProto::status() const {
  return status_;
}
inline void ResourceProto::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ResourceGroupProto

// optional string groupId = 1;
inline bool ResourceGroupProto::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceGroupProto::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceGroupProto::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceGroupProto::clear_groupid() {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    groupid_->clear();
  }
  clear_has_groupid();
}
inline const ::std::string& ResourceGroupProto::groupid() const {
  return *groupid_;
}
inline void ResourceGroupProto::set_groupid(const ::std::string& value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void ResourceGroupProto::set_groupid(const char* value) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(value);
}
inline void ResourceGroupProto::set_groupid(const char* value, size_t size) {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  groupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceGroupProto::mutable_groupid() {
  set_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    groupid_ = new ::std::string;
  }
  return groupid_;
}
inline ::std::string* ResourceGroupProto::release_groupid() {
  clear_has_groupid();
  if (groupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupid_;
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceGroupProto::set_allocated_groupid(::std::string* groupid) {
  if (groupid_ != &::google::protobuf::internal::kEmptyString) {
    delete groupid_;
  }
  if (groupid) {
    set_has_groupid();
    groupid_ = groupid;
  } else {
    clear_has_groupid();
    groupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ResourceProto resources = 2;
inline int ResourceGroupProto::resources_size() const {
  return resources_.size();
}
inline void ResourceGroupProto::clear_resources() {
  resources_.Clear();
}
inline const ::ResourceProto& ResourceGroupProto::resources(int index) const {
  return resources_.Get(index);
}
inline ::ResourceProto* ResourceGroupProto::mutable_resources(int index) {
  return resources_.Mutable(index);
}
inline ::ResourceProto* ResourceGroupProto::add_resources() {
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ResourceProto >&
ResourceGroupProto::resources() const {
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::ResourceProto >*
ResourceGroupProto::mutable_resources() {
  return &resources_;
}

// -------------------------------------------------------------------

// NodeReportProto

// required string hostname = 1;
inline bool NodeReportProto::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeReportProto::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeReportProto::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeReportProto::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& NodeReportProto::hostname() const {
  return *hostname_;
}
inline void NodeReportProto::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void NodeReportProto::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void NodeReportProto::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeReportProto::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* NodeReportProto::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeReportProto::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string state = 2;
inline bool NodeReportProto::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeReportProto::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeReportProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeReportProto::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& NodeReportProto::state() const {
  return *state_;
}
inline void NodeReportProto::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void NodeReportProto::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void NodeReportProto::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeReportProto::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* NodeReportProto::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeReportProto::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string rack = 3;
inline bool NodeReportProto::has_rack() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeReportProto::set_has_rack() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeReportProto::clear_has_rack() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeReportProto::clear_rack() {
  if (rack_ != &::google::protobuf::internal::kEmptyString) {
    rack_->clear();
  }
  clear_has_rack();
}
inline const ::std::string& NodeReportProto::rack() const {
  return *rack_;
}
inline void NodeReportProto::set_rack(const ::std::string& value) {
  set_has_rack();
  if (rack_ == &::google::protobuf::internal::kEmptyString) {
    rack_ = new ::std::string;
  }
  rack_->assign(value);
}
inline void NodeReportProto::set_rack(const char* value) {
  set_has_rack();
  if (rack_ == &::google::protobuf::internal::kEmptyString) {
    rack_ = new ::std::string;
  }
  rack_->assign(value);
}
inline void NodeReportProto::set_rack(const char* value, size_t size) {
  set_has_rack();
  if (rack_ == &::google::protobuf::internal::kEmptyString) {
    rack_ = new ::std::string;
  }
  rack_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeReportProto::mutable_rack() {
  set_has_rack();
  if (rack_ == &::google::protobuf::internal::kEmptyString) {
    rack_ = new ::std::string;
  }
  return rack_;
}
inline ::std::string* NodeReportProto::release_rack() {
  clear_has_rack();
  if (rack_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rack_;
    rack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeReportProto::set_allocated_rack(::std::string* rack) {
  if (rack_ != &::google::protobuf::internal::kEmptyString) {
    delete rack_;
  }
  if (rack) {
    set_has_rack();
    rack_ = rack;
  } else {
    clear_has_rack();
    rack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 container_num = 4;
inline bool NodeReportProto::has_container_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeReportProto::set_has_container_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeReportProto::clear_has_container_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeReportProto::clear_container_num() {
  container_num_ = 0;
  clear_has_container_num();
}
inline ::google::protobuf::int32 NodeReportProto::container_num() const {
  return container_num_;
}
inline void NodeReportProto::set_container_num(::google::protobuf::int32 value) {
  set_has_container_num();
  container_num_ = value;
}

// required int32 memory = 5;
inline bool NodeReportProto::has_memory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeReportProto::set_has_memory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeReportProto::clear_has_memory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeReportProto::clear_memory() {
  memory_ = 0;
  clear_has_memory();
}
inline ::google::protobuf::int32 NodeReportProto::memory() const {
  return memory_;
}
inline void NodeReportProto::set_memory(::google::protobuf::int32 value) {
  set_has_memory();
  memory_ = value;
}

// required int32 cpu = 6;
inline bool NodeReportProto::has_cpu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeReportProto::set_has_cpu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeReportProto::clear_has_cpu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeReportProto::clear_cpu() {
  cpu_ = 0;
  clear_has_cpu();
}
inline ::google::protobuf::int32 NodeReportProto::cpu() const {
  return cpu_;
}
inline void NodeReportProto::set_cpu(::google::protobuf::int32 value) {
  set_has_cpu();
  cpu_ = value;
}

// required string healthReport = 7;
inline bool NodeReportProto::has_healthreport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeReportProto::set_has_healthreport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeReportProto::clear_has_healthreport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeReportProto::clear_healthreport() {
  if (healthreport_ != &::google::protobuf::internal::kEmptyString) {
    healthreport_->clear();
  }
  clear_has_healthreport();
}
inline const ::std::string& NodeReportProto::healthreport() const {
  return *healthreport_;
}
inline void NodeReportProto::set_healthreport(const ::std::string& value) {
  set_has_healthreport();
  if (healthreport_ == &::google::protobuf::internal::kEmptyString) {
    healthreport_ = new ::std::string;
  }
  healthreport_->assign(value);
}
inline void NodeReportProto::set_healthreport(const char* value) {
  set_has_healthreport();
  if (healthreport_ == &::google::protobuf::internal::kEmptyString) {
    healthreport_ = new ::std::string;
  }
  healthreport_->assign(value);
}
inline void NodeReportProto::set_healthreport(const char* value, size_t size) {
  set_has_healthreport();
  if (healthreport_ == &::google::protobuf::internal::kEmptyString) {
    healthreport_ = new ::std::string;
  }
  healthreport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeReportProto::mutable_healthreport() {
  set_has_healthreport();
  if (healthreport_ == &::google::protobuf::internal::kEmptyString) {
    healthreport_ = new ::std::string;
  }
  return healthreport_;
}
inline ::std::string* NodeReportProto::release_healthreport() {
  clear_has_healthreport();
  if (healthreport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = healthreport_;
    healthreport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeReportProto::set_allocated_healthreport(::std::string* healthreport) {
  if (healthreport_ != &::google::protobuf::internal::kEmptyString) {
    delete healthreport_;
  }
  if (healthreport) {
    set_has_healthreport();
    healthreport_ = healthreport;
  } else {
    clear_has_healthreport();
    healthreport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string lastHealthReportTime = 8;
inline bool NodeReportProto::has_lasthealthreporttime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeReportProto::set_has_lasthealthreporttime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeReportProto::clear_has_lasthealthreporttime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeReportProto::clear_lasthealthreporttime() {
  if (lasthealthreporttime_ != &::google::protobuf::internal::kEmptyString) {
    lasthealthreporttime_->clear();
  }
  clear_has_lasthealthreporttime();
}
inline const ::std::string& NodeReportProto::lasthealthreporttime() const {
  return *lasthealthreporttime_;
}
inline void NodeReportProto::set_lasthealthreporttime(const ::std::string& value) {
  set_has_lasthealthreporttime();
  if (lasthealthreporttime_ == &::google::protobuf::internal::kEmptyString) {
    lasthealthreporttime_ = new ::std::string;
  }
  lasthealthreporttime_->assign(value);
}
inline void NodeReportProto::set_lasthealthreporttime(const char* value) {
  set_has_lasthealthreporttime();
  if (lasthealthreporttime_ == &::google::protobuf::internal::kEmptyString) {
    lasthealthreporttime_ = new ::std::string;
  }
  lasthealthreporttime_->assign(value);
}
inline void NodeReportProto::set_lasthealthreporttime(const char* value, size_t size) {
  set_has_lasthealthreporttime();
  if (lasthealthreporttime_ == &::google::protobuf::internal::kEmptyString) {
    lasthealthreporttime_ = new ::std::string;
  }
  lasthealthreporttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeReportProto::mutable_lasthealthreporttime() {
  set_has_lasthealthreporttime();
  if (lasthealthreporttime_ == &::google::protobuf::internal::kEmptyString) {
    lasthealthreporttime_ = new ::std::string;
  }
  return lasthealthreporttime_;
}
inline ::std::string* NodeReportProto::release_lasthealthreporttime() {
  clear_has_lasthealthreporttime();
  if (lasthealthreporttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lasthealthreporttime_;
    lasthealthreporttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeReportProto::set_allocated_lasthealthreporttime(::std::string* lasthealthreporttime) {
  if (lasthealthreporttime_ != &::google::protobuf::internal::kEmptyString) {
    delete lasthealthreporttime_;
  }
  if (lasthealthreporttime) {
    set_has_lasthealthreporttime();
    lasthealthreporttime_ = lasthealthreporttime;
  } else {
    clear_has_lasthealthreporttime();
    lasthealthreporttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClusterReportProto

// repeated .NodeReportProto nodes = 1;
inline int ClusterReportProto::nodes_size() const {
  return nodes_.size();
}
inline void ClusterReportProto::clear_nodes() {
  nodes_.Clear();
}
inline const ::NodeReportProto& ClusterReportProto::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::NodeReportProto* ClusterReportProto::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::NodeReportProto* ClusterReportProto::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeReportProto >&
ClusterReportProto::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeReportProto >*
ClusterReportProto::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// NodeResourceProto

// required string hostname = 1;
inline bool NodeResourceProto::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeResourceProto::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeResourceProto::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeResourceProto::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& NodeResourceProto::hostname() const {
  return *hostname_;
}
inline void NodeResourceProto::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void NodeResourceProto::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void NodeResourceProto::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeResourceProto::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* NodeResourceProto::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeResourceProto::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ip = 2;
inline bool NodeResourceProto::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeResourceProto::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeResourceProto::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeResourceProto::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& NodeResourceProto::ip() const {
  return *ip_;
}
inline void NodeResourceProto::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NodeResourceProto::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void NodeResourceProto::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeResourceProto::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* NodeResourceProto::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeResourceProto::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 min_memory = 3;
inline bool NodeResourceProto::has_min_memory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeResourceProto::set_has_min_memory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeResourceProto::clear_has_min_memory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeResourceProto::clear_min_memory() {
  min_memory_ = 0;
  clear_has_min_memory();
}
inline ::google::protobuf::int32 NodeResourceProto::min_memory() const {
  return min_memory_;
}
inline void NodeResourceProto::set_min_memory(::google::protobuf::int32 value) {
  set_has_min_memory();
  min_memory_ = value;
}

// required int32 max_memory = 4;
inline bool NodeResourceProto::has_max_memory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeResourceProto::set_has_max_memory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeResourceProto::clear_has_max_memory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeResourceProto::clear_max_memory() {
  max_memory_ = 0;
  clear_has_max_memory();
}
inline ::google::protobuf::int32 NodeResourceProto::max_memory() const {
  return max_memory_;
}
inline void NodeResourceProto::set_max_memory(::google::protobuf::int32 value) {
  set_has_max_memory();
  max_memory_ = value;
}

// required int32 free_memory = 5;
inline bool NodeResourceProto::has_free_memory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeResourceProto::set_has_free_memory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeResourceProto::clear_has_free_memory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeResourceProto::clear_free_memory() {
  free_memory_ = 0;
  clear_has_free_memory();
}
inline ::google::protobuf::int32 NodeResourceProto::free_memory() const {
  return free_memory_;
}
inline void NodeResourceProto::set_free_memory(::google::protobuf::int32 value) {
  set_has_free_memory();
  free_memory_ = value;
}

// required int32 min_cpu = 6;
inline bool NodeResourceProto::has_min_cpu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeResourceProto::set_has_min_cpu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeResourceProto::clear_has_min_cpu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeResourceProto::clear_min_cpu() {
  min_cpu_ = 0;
  clear_has_min_cpu();
}
inline ::google::protobuf::int32 NodeResourceProto::min_cpu() const {
  return min_cpu_;
}
inline void NodeResourceProto::set_min_cpu(::google::protobuf::int32 value) {
  set_has_min_cpu();
  min_cpu_ = value;
}

// required int32 max_cpu = 7;
inline bool NodeResourceProto::has_max_cpu() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeResourceProto::set_has_max_cpu() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeResourceProto::clear_has_max_cpu() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeResourceProto::clear_max_cpu() {
  max_cpu_ = 0;
  clear_has_max_cpu();
}
inline ::google::protobuf::int32 NodeResourceProto::max_cpu() const {
  return max_cpu_;
}
inline void NodeResourceProto::set_max_cpu(::google::protobuf::int32 value) {
  set_has_max_cpu();
  max_cpu_ = value;
}

// required int32 free_cpu = 8;
inline bool NodeResourceProto::has_free_cpu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeResourceProto::set_has_free_cpu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeResourceProto::clear_has_free_cpu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeResourceProto::clear_free_cpu() {
  free_cpu_ = 0;
  clear_has_free_cpu();
}
inline ::google::protobuf::int32 NodeResourceProto::free_cpu() const {
  return free_cpu_;
}
inline void NodeResourceProto::set_free_cpu(::google::protobuf::int32 value) {
  set_has_free_cpu();
  free_cpu_ = value;
}

// -------------------------------------------------------------------

// ClusterResourceProto

// repeated .NodeResourceProto nodes = 1;
inline int ClusterResourceProto::nodes_size() const {
  return nodes_.size();
}
inline void ClusterResourceProto::clear_nodes() {
  nodes_.Clear();
}
inline const ::NodeResourceProto& ClusterResourceProto::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::NodeResourceProto* ClusterResourceProto::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::NodeResourceProto* ClusterResourceProto::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeResourceProto >&
ClusterResourceProto::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeResourceProto >*
ClusterResourceProto::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// CreateJobRequestProto

// required .JobContextProto jobContext = 1;
inline bool CreateJobRequestProto::has_jobcontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateJobRequestProto::set_has_jobcontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateJobRequestProto::clear_has_jobcontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateJobRequestProto::clear_jobcontext() {
  if (jobcontext_ != NULL) jobcontext_->::JobContextProto::Clear();
  clear_has_jobcontext();
}
inline const ::JobContextProto& CreateJobRequestProto::jobcontext() const {
  return jobcontext_ != NULL ? *jobcontext_ : *default_instance_->jobcontext_;
}
inline ::JobContextProto* CreateJobRequestProto::mutable_jobcontext() {
  set_has_jobcontext();
  if (jobcontext_ == NULL) jobcontext_ = new ::JobContextProto;
  return jobcontext_;
}
inline ::JobContextProto* CreateJobRequestProto::release_jobcontext() {
  clear_has_jobcontext();
  ::JobContextProto* temp = jobcontext_;
  jobcontext_ = NULL;
  return temp;
}
inline void CreateJobRequestProto::set_allocated_jobcontext(::JobContextProto* jobcontext) {
  delete jobcontext_;
  jobcontext_ = jobcontext;
  if (jobcontext) {
    set_has_jobcontext();
  } else {
    clear_has_jobcontext();
  }
}

// -------------------------------------------------------------------

// CreateJobResponseProto

// required .JobContextProto jobContext = 1;
inline bool CreateJobResponseProto::has_jobcontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateJobResponseProto::set_has_jobcontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateJobResponseProto::clear_has_jobcontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateJobResponseProto::clear_jobcontext() {
  if (jobcontext_ != NULL) jobcontext_->::JobContextProto::Clear();
  clear_has_jobcontext();
}
inline const ::JobContextProto& CreateJobResponseProto::jobcontext() const {
  return jobcontext_ != NULL ? *jobcontext_ : *default_instance_->jobcontext_;
}
inline ::JobContextProto* CreateJobResponseProto::mutable_jobcontext() {
  set_has_jobcontext();
  if (jobcontext_ == NULL) jobcontext_ = new ::JobContextProto;
  return jobcontext_;
}
inline ::JobContextProto* CreateJobResponseProto::release_jobcontext() {
  clear_has_jobcontext();
  ::JobContextProto* temp = jobcontext_;
  jobcontext_ = NULL;
  return temp;
}
inline void CreateJobResponseProto::set_allocated_jobcontext(::JobContextProto* jobcontext) {
  delete jobcontext_;
  jobcontext_ = jobcontext;
  if (jobcontext) {
    set_has_jobcontext();
  } else {
    clear_has_jobcontext();
  }
}

// -------------------------------------------------------------------

// FinishJobRequestProto

// required .JobContextProto jobContext = 1;
inline bool FinishJobRequestProto::has_jobcontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishJobRequestProto::set_has_jobcontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishJobRequestProto::clear_has_jobcontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishJobRequestProto::clear_jobcontext() {
  if (jobcontext_ != NULL) jobcontext_->::JobContextProto::Clear();
  clear_has_jobcontext();
}
inline const ::JobContextProto& FinishJobRequestProto::jobcontext() const {
  return jobcontext_ != NULL ? *jobcontext_ : *default_instance_->jobcontext_;
}
inline ::JobContextProto* FinishJobRequestProto::mutable_jobcontext() {
  set_has_jobcontext();
  if (jobcontext_ == NULL) jobcontext_ = new ::JobContextProto;
  return jobcontext_;
}
inline ::JobContextProto* FinishJobRequestProto::release_jobcontext() {
  clear_has_jobcontext();
  ::JobContextProto* temp = jobcontext_;
  jobcontext_ = NULL;
  return temp;
}
inline void FinishJobRequestProto::set_allocated_jobcontext(::JobContextProto* jobcontext) {
  delete jobcontext_;
  jobcontext_ = jobcontext;
  if (jobcontext) {
    set_has_jobcontext();
  } else {
    clear_has_jobcontext();
  }
}

// -------------------------------------------------------------------

// FinishJobResponseProto

// required .JobContextProto jobContext = 1;
inline bool FinishJobResponseProto::has_jobcontext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishJobResponseProto::set_has_jobcontext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishJobResponseProto::clear_has_jobcontext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishJobResponseProto::clear_jobcontext() {
  if (jobcontext_ != NULL) jobcontext_->::JobContextProto::Clear();
  clear_has_jobcontext();
}
inline const ::JobContextProto& FinishJobResponseProto::jobcontext() const {
  return jobcontext_ != NULL ? *jobcontext_ : *default_instance_->jobcontext_;
}
inline ::JobContextProto* FinishJobResponseProto::mutable_jobcontext() {
  set_has_jobcontext();
  if (jobcontext_ == NULL) jobcontext_ = new ::JobContextProto;
  return jobcontext_;
}
inline ::JobContextProto* FinishJobResponseProto::release_jobcontext() {
  clear_has_jobcontext();
  ::JobContextProto* temp = jobcontext_;
  jobcontext_ = NULL;
  return temp;
}
inline void FinishJobResponseProto::set_allocated_jobcontext(::JobContextProto* jobcontext) {
  delete jobcontext_;
  jobcontext_ = jobcontext;
  if (jobcontext) {
    set_has_jobcontext();
  } else {
    clear_has_jobcontext();
  }
}

// -------------------------------------------------------------------

// AllocateResourcesRequestProto

// required string jobId = 1;
inline bool AllocateResourcesRequestProto::has_jobid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocateResourcesRequestProto::set_has_jobid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllocateResourcesRequestProto::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllocateResourcesRequestProto::clear_jobid() {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    jobid_->clear();
  }
  clear_has_jobid();
}
inline const ::std::string& AllocateResourcesRequestProto::jobid() const {
  return *jobid_;
}
inline void AllocateResourcesRequestProto::set_jobid(const ::std::string& value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void AllocateResourcesRequestProto::set_jobid(const char* value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void AllocateResourcesRequestProto::set_jobid(const char* value, size_t size) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocateResourcesRequestProto::mutable_jobid() {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  return jobid_;
}
inline ::std::string* AllocateResourcesRequestProto::release_jobid() {
  clear_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobid_;
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllocateResourcesRequestProto::set_allocated_jobid(::std::string* jobid) {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    delete jobid_;
  }
  if (jobid) {
    set_has_jobid();
    jobid_ = jobid;
  } else {
    clear_has_jobid();
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ResourceGroupProto resourceGroup = 2;
inline bool AllocateResourcesRequestProto::has_resourcegroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocateResourcesRequestProto::set_has_resourcegroup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllocateResourcesRequestProto::clear_has_resourcegroup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllocateResourcesRequestProto::clear_resourcegroup() {
  if (resourcegroup_ != NULL) resourcegroup_->::ResourceGroupProto::Clear();
  clear_has_resourcegroup();
}
inline const ::ResourceGroupProto& AllocateResourcesRequestProto::resourcegroup() const {
  return resourcegroup_ != NULL ? *resourcegroup_ : *default_instance_->resourcegroup_;
}
inline ::ResourceGroupProto* AllocateResourcesRequestProto::mutable_resourcegroup() {
  set_has_resourcegroup();
  if (resourcegroup_ == NULL) resourcegroup_ = new ::ResourceGroupProto;
  return resourcegroup_;
}
inline ::ResourceGroupProto* AllocateResourcesRequestProto::release_resourcegroup() {
  clear_has_resourcegroup();
  ::ResourceGroupProto* temp = resourcegroup_;
  resourcegroup_ = NULL;
  return temp;
}
inline void AllocateResourcesRequestProto::set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup) {
  delete resourcegroup_;
  resourcegroup_ = resourcegroup;
  if (resourcegroup) {
    set_has_resourcegroup();
  } else {
    clear_has_resourcegroup();
  }
}

// -------------------------------------------------------------------

// AllocateResourcesResponseProto

// required .ResourceGroupProto resourceGroup = 1;
inline bool AllocateResourcesResponseProto::has_resourcegroup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocateResourcesResponseProto::set_has_resourcegroup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllocateResourcesResponseProto::clear_has_resourcegroup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllocateResourcesResponseProto::clear_resourcegroup() {
  if (resourcegroup_ != NULL) resourcegroup_->::ResourceGroupProto::Clear();
  clear_has_resourcegroup();
}
inline const ::ResourceGroupProto& AllocateResourcesResponseProto::resourcegroup() const {
  return resourcegroup_ != NULL ? *resourcegroup_ : *default_instance_->resourcegroup_;
}
inline ::ResourceGroupProto* AllocateResourcesResponseProto::mutable_resourcegroup() {
  set_has_resourcegroup();
  if (resourcegroup_ == NULL) resourcegroup_ = new ::ResourceGroupProto;
  return resourcegroup_;
}
inline ::ResourceGroupProto* AllocateResourcesResponseProto::release_resourcegroup() {
  clear_has_resourcegroup();
  ::ResourceGroupProto* temp = resourcegroup_;
  resourcegroup_ = NULL;
  return temp;
}
inline void AllocateResourcesResponseProto::set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup) {
  delete resourcegroup_;
  resourcegroup_ = resourcegroup;
  if (resourcegroup) {
    set_has_resourcegroup();
  } else {
    clear_has_resourcegroup();
  }
}

// -------------------------------------------------------------------

// ActiveResourcesRequestProto

// required string jobId = 1;
inline bool ActiveResourcesRequestProto::has_jobid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveResourcesRequestProto::set_has_jobid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveResourcesRequestProto::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveResourcesRequestProto::clear_jobid() {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    jobid_->clear();
  }
  clear_has_jobid();
}
inline const ::std::string& ActiveResourcesRequestProto::jobid() const {
  return *jobid_;
}
inline void ActiveResourcesRequestProto::set_jobid(const ::std::string& value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void ActiveResourcesRequestProto::set_jobid(const char* value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void ActiveResourcesRequestProto::set_jobid(const char* value, size_t size) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActiveResourcesRequestProto::mutable_jobid() {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  return jobid_;
}
inline ::std::string* ActiveResourcesRequestProto::release_jobid() {
  clear_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobid_;
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActiveResourcesRequestProto::set_allocated_jobid(::std::string* jobid) {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    delete jobid_;
  }
  if (jobid) {
    set_has_jobid();
    jobid_ = jobid;
  } else {
    clear_has_jobid();
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ResourceGroupProto resourceGroup = 2;
inline bool ActiveResourcesRequestProto::has_resourcegroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveResourcesRequestProto::set_has_resourcegroup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActiveResourcesRequestProto::clear_has_resourcegroup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActiveResourcesRequestProto::clear_resourcegroup() {
  if (resourcegroup_ != NULL) resourcegroup_->::ResourceGroupProto::Clear();
  clear_has_resourcegroup();
}
inline const ::ResourceGroupProto& ActiveResourcesRequestProto::resourcegroup() const {
  return resourcegroup_ != NULL ? *resourcegroup_ : *default_instance_->resourcegroup_;
}
inline ::ResourceGroupProto* ActiveResourcesRequestProto::mutable_resourcegroup() {
  set_has_resourcegroup();
  if (resourcegroup_ == NULL) resourcegroup_ = new ::ResourceGroupProto;
  return resourcegroup_;
}
inline ::ResourceGroupProto* ActiveResourcesRequestProto::release_resourcegroup() {
  clear_has_resourcegroup();
  ::ResourceGroupProto* temp = resourcegroup_;
  resourcegroup_ = NULL;
  return temp;
}
inline void ActiveResourcesRequestProto::set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup) {
  delete resourcegroup_;
  resourcegroup_ = resourcegroup;
  if (resourcegroup) {
    set_has_resourcegroup();
  } else {
    clear_has_resourcegroup();
  }
}

// -------------------------------------------------------------------

// ActiveResourcesResponseProto

// required .ResourceGroupProto resourceGroup = 1;
inline bool ActiveResourcesResponseProto::has_resourcegroup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveResourcesResponseProto::set_has_resourcegroup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveResourcesResponseProto::clear_has_resourcegroup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveResourcesResponseProto::clear_resourcegroup() {
  if (resourcegroup_ != NULL) resourcegroup_->::ResourceGroupProto::Clear();
  clear_has_resourcegroup();
}
inline const ::ResourceGroupProto& ActiveResourcesResponseProto::resourcegroup() const {
  return resourcegroup_ != NULL ? *resourcegroup_ : *default_instance_->resourcegroup_;
}
inline ::ResourceGroupProto* ActiveResourcesResponseProto::mutable_resourcegroup() {
  set_has_resourcegroup();
  if (resourcegroup_ == NULL) resourcegroup_ = new ::ResourceGroupProto;
  return resourcegroup_;
}
inline ::ResourceGroupProto* ActiveResourcesResponseProto::release_resourcegroup() {
  clear_has_resourcegroup();
  ::ResourceGroupProto* temp = resourcegroup_;
  resourcegroup_ = NULL;
  return temp;
}
inline void ActiveResourcesResponseProto::set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup) {
  delete resourcegroup_;
  resourcegroup_ = resourcegroup;
  if (resourcegroup) {
    set_has_resourcegroup();
  } else {
    clear_has_resourcegroup();
  }
}

// -------------------------------------------------------------------

// ReleaseResourcesRequestProto

// required string jobId = 1;
inline bool ReleaseResourcesRequestProto::has_jobid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseResourcesRequestProto::set_has_jobid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseResourcesRequestProto::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseResourcesRequestProto::clear_jobid() {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    jobid_->clear();
  }
  clear_has_jobid();
}
inline const ::std::string& ReleaseResourcesRequestProto::jobid() const {
  return *jobid_;
}
inline void ReleaseResourcesRequestProto::set_jobid(const ::std::string& value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void ReleaseResourcesRequestProto::set_jobid(const char* value) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(value);
}
inline void ReleaseResourcesRequestProto::set_jobid(const char* value, size_t size) {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  jobid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseResourcesRequestProto::mutable_jobid() {
  set_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    jobid_ = new ::std::string;
  }
  return jobid_;
}
inline ::std::string* ReleaseResourcesRequestProto::release_jobid() {
  clear_has_jobid();
  if (jobid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jobid_;
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReleaseResourcesRequestProto::set_allocated_jobid(::std::string* jobid) {
  if (jobid_ != &::google::protobuf::internal::kEmptyString) {
    delete jobid_;
  }
  if (jobid) {
    set_has_jobid();
    jobid_ = jobid;
  } else {
    clear_has_jobid();
    jobid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ResourceGroupProto resourceGroup = 2;
inline bool ReleaseResourcesRequestProto::has_resourcegroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReleaseResourcesRequestProto::set_has_resourcegroup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReleaseResourcesRequestProto::clear_has_resourcegroup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReleaseResourcesRequestProto::clear_resourcegroup() {
  if (resourcegroup_ != NULL) resourcegroup_->::ResourceGroupProto::Clear();
  clear_has_resourcegroup();
}
inline const ::ResourceGroupProto& ReleaseResourcesRequestProto::resourcegroup() const {
  return resourcegroup_ != NULL ? *resourcegroup_ : *default_instance_->resourcegroup_;
}
inline ::ResourceGroupProto* ReleaseResourcesRequestProto::mutable_resourcegroup() {
  set_has_resourcegroup();
  if (resourcegroup_ == NULL) resourcegroup_ = new ::ResourceGroupProto;
  return resourcegroup_;
}
inline ::ResourceGroupProto* ReleaseResourcesRequestProto::release_resourcegroup() {
  clear_has_resourcegroup();
  ::ResourceGroupProto* temp = resourcegroup_;
  resourcegroup_ = NULL;
  return temp;
}
inline void ReleaseResourcesRequestProto::set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup) {
  delete resourcegroup_;
  resourcegroup_ = resourcegroup;
  if (resourcegroup) {
    set_has_resourcegroup();
  } else {
    clear_has_resourcegroup();
  }
}

// -------------------------------------------------------------------

// ReleaseResourcesResponseProto

// required .ResourceGroupProto resourceGroup = 1;
inline bool ReleaseResourcesResponseProto::has_resourcegroup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseResourcesResponseProto::set_has_resourcegroup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseResourcesResponseProto::clear_has_resourcegroup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseResourcesResponseProto::clear_resourcegroup() {
  if (resourcegroup_ != NULL) resourcegroup_->::ResourceGroupProto::Clear();
  clear_has_resourcegroup();
}
inline const ::ResourceGroupProto& ReleaseResourcesResponseProto::resourcegroup() const {
  return resourcegroup_ != NULL ? *resourcegroup_ : *default_instance_->resourcegroup_;
}
inline ::ResourceGroupProto* ReleaseResourcesResponseProto::mutable_resourcegroup() {
  set_has_resourcegroup();
  if (resourcegroup_ == NULL) resourcegroup_ = new ::ResourceGroupProto;
  return resourcegroup_;
}
inline ::ResourceGroupProto* ReleaseResourcesResponseProto::release_resourcegroup() {
  clear_has_resourcegroup();
  ::ResourceGroupProto* temp = resourcegroup_;
  resourcegroup_ = NULL;
  return temp;
}
inline void ReleaseResourcesResponseProto::set_allocated_resourcegroup(::ResourceGroupProto* resourcegroup) {
  delete resourcegroup_;
  resourcegroup_ = resourcegroup;
  if (resourcegroup) {
    set_has_resourcegroup();
  } else {
    clear_has_resourcegroup();
  }
}

// -------------------------------------------------------------------

// GetClusterReportRequestProto

// required .NodeStateProto state = 1;
inline bool GetClusterReportRequestProto::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterReportRequestProto::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterReportRequestProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterReportRequestProto::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::NodeStateProto GetClusterReportRequestProto::state() const {
  return static_cast< ::NodeStateProto >(state_);
}
inline void GetClusterReportRequestProto::set_state(::NodeStateProto value) {
  assert(::NodeStateProto_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// GetClusterReportResponseProto

// required .ClusterReportProto report = 1;
inline bool GetClusterReportResponseProto::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterReportResponseProto::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterReportResponseProto::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterReportResponseProto::clear_report() {
  if (report_ != NULL) report_->::ClusterReportProto::Clear();
  clear_has_report();
}
inline const ::ClusterReportProto& GetClusterReportResponseProto::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::ClusterReportProto* GetClusterReportResponseProto::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::ClusterReportProto;
  return report_;
}
inline ::ClusterReportProto* GetClusterReportResponseProto::release_report() {
  clear_has_report();
  ::ClusterReportProto* temp = report_;
  report_ = NULL;
  return temp;
}
inline void GetClusterReportResponseProto::set_allocated_report(::ClusterReportProto* report) {
  delete report_;
  report_ = report;
  if (report) {
    set_has_report();
  } else {
    clear_has_report();
  }
}

// -------------------------------------------------------------------

// GetClusterResourceRequestProto

// required .NodeStateProto state = 1;
inline bool GetClusterResourceRequestProto::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterResourceRequestProto::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterResourceRequestProto::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterResourceRequestProto::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::NodeStateProto GetClusterResourceRequestProto::state() const {
  return static_cast< ::NodeStateProto >(state_);
}
inline void GetClusterResourceRequestProto::set_state(::NodeStateProto value) {
  assert(::NodeStateProto_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// GetClusterResourceResponseProto

// required .ClusterResourceProto resources = 1;
inline bool GetClusterResourceResponseProto::has_resources() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterResourceResponseProto::set_has_resources() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterResourceResponseProto::clear_has_resources() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterResourceResponseProto::clear_resources() {
  if (resources_ != NULL) resources_->::ClusterResourceProto::Clear();
  clear_has_resources();
}
inline const ::ClusterResourceProto& GetClusterResourceResponseProto::resources() const {
  return resources_ != NULL ? *resources_ : *default_instance_->resources_;
}
inline ::ClusterResourceProto* GetClusterResourceResponseProto::mutable_resources() {
  set_has_resources();
  if (resources_ == NULL) resources_ = new ::ClusterResourceProto;
  return resources_;
}
inline ::ClusterResourceProto* GetClusterResourceResponseProto::release_resources() {
  clear_has_resources();
  ::ClusterResourceProto* temp = resources_;
  resources_ = NULL;
  return temp;
}
inline void GetClusterResourceResponseProto::set_allocated_resources(::ClusterResourceProto* resources) {
  delete resources_;
  resources_ = resources;
  if (resources) {
    set_has_resources();
  } else {
    clear_has_resources();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NodeStateProto>() {
  return ::NodeStateProto_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_yarnsimulator_2eproto__INCLUDED
