{
   "insert into gp_distribution_policy" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbcat.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (localoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_1(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = GpPolicyRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(GpPolicyRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_1",
      "func_note" : "",
      "func_number" : "1",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_1(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tGpPolicyLocalOidIndexId: localoid\n\t*/\n\t/* gp_distribution_policy: do not get exclusive lock */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (localoid) \n\t\t*/\n\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_1 */\n",
      "iud_func_name" : "caql_iud_fn_1",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "gp_distribution_policy"
   },
   "insert into gp_segment_configuration" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/gp/segadmin.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_2(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = GpSegmentConfigRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(GpSegmentConfigRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_2",
      "func_note" : "",
      "func_number" : "2",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_2(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tGpSegmentConfigRegistration_orderIndexId: registration_order\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_gp_segment_configuration_registration_order,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, GpSegmentConfigRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"gp_segment_configuration\",\n\t\t\t\t\t  \"registration_order\",\n\t\t\t\t\t  GpSegmentConfigRegistration_orderIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_gp_segment_configuration_registration_order,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, GpSegmentConfigRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"gp_segment_configuration\",\n\t\t\t\t\t  \"registration_order\",\n\t\t\t\t\t  GpSegmentConfigRegistration_orderIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE/DELETE: no references\n\t\t   gp_segment_configuration is unrelated to any other table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_2 */\n",
      "iud_func_name" : "caql_iud_fn_2",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "gp_segment_configuration"
   },
   "insert into pg_aggregate" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_aggregate.c" : 1
      },
      "foreign_key_tables" : {
         "pg_operator" : {
            "(oid) <- (aggsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (aggfinalfn)" : 1,
            "(oid) <- (aggfnoid)" : 1,
            "(oid) <- (agginvprelimfn)" : 1,
            "(oid) <- (agginvtransfn)" : 1,
            "(oid) <- (aggprelimfn)" : 1,
            "(oid) <- (aggtransfn)" : 1
         },
         "pg_type" : {
            "(oid) <- (aggtranstype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_3(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AggregateRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AggregateRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_3",
      "func_note" : "",
      "func_number" : "3",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_3(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tAggregateAggfnoidIndexId: aggfnoid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggfnoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AggregateRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_aggregate\",\n\t\t\t\t\t  \"aggfnoid\",\n\t\t\t\t\t  AggregateAggfnoidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggfnoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AggregateRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_aggregate\",\n\t\t\t\t\t  \"aggfnoid\",\n\t\t\t\t\t  AggregateAggfnoidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_operator (oid) <- (aggsortop)\n\t\t  pg_proc (oid) <- (aggfinalfn)\n\t\t  pg_proc (oid) <- (aggfnoid)\n\t\t  pg_proc (oid) <- (agginvprelimfn)\n\t\t  pg_proc (oid) <- (agginvtransfn)\n\t\t  pg_proc (oid) <- (aggprelimfn)\n\t\t  pg_proc (oid) <- (aggtransfn)\n\t\t  pg_type (oid) <- (aggtranstype) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggsortop,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggsortop,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggfinalfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggfinalfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggfnoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggfnoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_agginvprelimfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_agginvprelimfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_agginvtransfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_agginvtransfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggprelimfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggprelimfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggtransfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggtransfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_aggregate_aggtranstype,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_aggregate_aggtranstype,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_3 */\n",
      "iud_func_name" : "caql_iud_fn_3",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_aggregate"
   },
   "insert into pg_amop" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/opclasscmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_4(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_4",
      "func_note" : "",
      "func_number" : "4",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_4(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tAccessMethodStrategyIndexId: amopclaid, amopsubtype, amopstrategy\n\tAccessMethodOperatorIndexId: amopopr, amopclaid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopclaid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopsubtype,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopstrategy,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodOperatorRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_amop\",\n\t\t\t\t\t  \"amopclaid, amopsubtype, amopstrategy\",\n\t\t\t\t\t  AccessMethodStrategyIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopclaid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopsubtype,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopstrategy,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodOperatorRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_amop\",\n\t\t\t\t\t  \"amopclaid, amopsubtype, amopstrategy\",\n\t\t\t\t\t  AccessMethodStrategyIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopopr,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopclaid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodOperatorRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_amop\",\n\t\t\t\t\t  \"amopopr, amopclaid\",\n\t\t\t\t\t  AccessMethodOperatorIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopopr,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopclaid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodOperatorRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_amop\",\n\t\t\t\t\t  \"amopopr, amopclaid\",\n\t\t\t\t\t  AccessMethodOperatorIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_opclass (oid) <- (amopclaid)\n\t\t  pg_operator (oid) <- (amopopr)\n\t\t  pg_type (oid) <- (amopsubtype) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopclaid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopclaid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopopr,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopopr,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amop_amopsubtype,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amop_amopsubtype,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_4 */\n",
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_amop"
   },
   "insert into pg_amproc" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/opclasscmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (amproc)" : 1
         },
         "pg_type" : {
            "(oid) <- (amprocsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_5(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AccessMethodProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_5",
      "func_note" : "",
      "func_number" : "5",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_5(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tAccessMethodProcedureIndexId: amopclaid, amprocsubtype, amprocnum\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amproc_amopclaid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amproc_amprocsubtype,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amproc_amprocnum,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodProcedureRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_amproc\",\n\t\t\t\t\t  \"amopclaid, amprocsubtype, amprocnum\",\n\t\t\t\t\t  AccessMethodProcedureIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amproc_amopclaid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amproc_amprocsubtype,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amproc_amprocnum,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodProcedureRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_amproc\",\n\t\t\t\t\t  \"amopclaid, amprocsubtype, amprocnum\",\n\t\t\t\t\t  AccessMethodProcedureIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_opclass (oid) <- (amopclaid)\n\t\t  pg_proc (oid) <- (amproc)\n\t\t  pg_type (oid) <- (amprocsubtype) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amproc_amopclaid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amproc_amopclaid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amproc_amproc,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amproc_amproc,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_amproc_amprocsubtype,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_amproc_amprocsubtype,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_5 */\n",
      "iud_func_name" : "caql_iud_fn_5",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_amproc"
   },
   "insert into pg_appendonly" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_appendonly.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (relid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_6(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AppendOnlyRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AppendOnlyRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_6",
      "func_note" : "",
      "func_number" : "6",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_6(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tAppendOnlyRelidIndexId: relid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_appendonly_relid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AppendOnlyRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_appendonly\",\n\t\t\t\t\t  \"relid\",\n\t\t\t\t\t  AppendOnlyRelidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_appendonly_relid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AppendOnlyRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_appendonly\",\n\t\t\t\t\t  \"relid\",\n\t\t\t\t\t  AppendOnlyRelidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (relid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_appendonly_relid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_appendonly_relid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_6 */\n",
      "iud_func_name" : "caql_iud_fn_6",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_appendonly"
   },
   "insert into pg_attrdef" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (adrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_7(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AttrDefaultRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttrDefaultRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_7",
      "func_note" : "",
      "func_number" : "7",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_7(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tAttrDefaultIndexId: adrelid, adnum\n\tAttrDefaultOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attrdef_adrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attrdef_adnum,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AttrDefaultRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_attrdef\",\n\t\t\t\t\t  \"adrelid, adnum\",\n\t\t\t\t\t  AttrDefaultIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attrdef_adrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attrdef_adnum,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AttrDefaultRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_attrdef\",\n\t\t\t\t\t  \"adrelid, adnum\",\n\t\t\t\t\t  AttrDefaultIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AttrDefaultRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_attrdef\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  AttrDefaultOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AttrDefaultRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_attrdef\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  AttrDefaultOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_attribute (attrelid) <- (adrelid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_7 */\n",
      "iud_func_name" : "caql_iud_fn_7",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_attrdef"
   },
   "insert into pg_attribute" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/catalog/index.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (attrelid)" : 1
         },
         "pg_type" : {
            "(oid) <- (atttypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_8(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AttributeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_8",
      "func_note" : "",
      "func_number" : "8",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_8(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tAttributeRelidNameIndexId: attrelid, attname\n\tAttributeRelidNumIndexId: attrelid, attnum\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_attrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_attname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t  \"attrelid, attname\",\n\t\t\t\t\t  AttributeRelidNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_attrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_attname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t  \"attrelid, attname\",\n\t\t\t\t\t  AttributeRelidNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_attrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_attnum,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t  \"attrelid, attnum\",\n\t\t\t\t\t  AttributeRelidNumIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_attrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_attnum,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t  \"attrelid, attnum\",\n\t\t\t\t\t  AttributeRelidNumIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_attribute primary key may be referenced in:\n\t\t  pg_attrdef (adrelid) <- (attrelid)\n\t\t  pg_attribute_encoding (attrelid) <- (attrelid)\n\t\t  pg_rewrite (ev_class) <- (attrelid)\n\t\t  pg_statistic (starelid) <- (attrelid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (attrelid)\n\t\t  pg_type (oid) <- (atttypid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_attrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_attrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_atttypid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_atttypid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_8 */\n",
      "iud_func_name" : "caql_iud_fn_8",
      "num_del_ops" : 0,
      "num_ins_ops" : 3,
      "num_upd_ops" : 0,
      "tablename" : "pg_attribute"
   },
   "insert into pg_attribute_encoding" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_attribute_encoding.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (attrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_9(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AttributeEncodingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeEncodingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_9",
      "func_note" : "",
      "func_number" : "9",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_9(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tAttributeEncodingAttrelidAttnumIndexId: attrelid, attnum\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_encoding_attrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_attribute_encoding_attnum,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AttributeEncodingRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_attribute_encoding\",\n\t\t\t\t\t  \"attrelid, attnum\",\n\t\t\t\t\t  AttributeEncodingAttrelidAttnumIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_encoding_attrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_attribute_encoding_attnum,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, AttributeEncodingRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_attribute_encoding\",\n\t\t\t\t\t  \"attrelid, attnum\",\n\t\t\t\t\t  AttributeEncodingAttrelidAttnumIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_attribute (attrelid) <- (attrelid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_9 */\n",
      "iud_func_name" : "caql_iud_fn_9",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_attribute_encoding"
   },
   "insert into pg_auth_members" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (member)" : 1,
            "(oid) <- (roleid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_10(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AuthMemRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthMemRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_10",
      "func_note" : "",
      "func_number" : "10",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_10(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tAuthMemRoleMemIndexId: roleid, member\n\tAuthMemMemRoleIndexId: member, roleid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_members_roleid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_members_member,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AuthMemRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_auth_members\",\n\t\t\t\t\t  \"roleid, member\",\n\t\t\t\t\t  AuthMemRoleMemIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_members_roleid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_members_member,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AuthMemRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_auth_members\",\n\t\t\t\t\t  \"roleid, member\",\n\t\t\t\t\t  AuthMemRoleMemIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_members_member,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_members_roleid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AuthMemRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_auth_members\",\n\t\t\t\t\t  \"member, roleid\",\n\t\t\t\t\t  AuthMemMemRoleIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_members_member,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_members_roleid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AuthMemRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_auth_members\",\n\t\t\t\t\t  \"member, roleid\",\n\t\t\t\t\t  AuthMemMemRoleIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (member)\n\t\t  pg_authid (oid) <- (roleid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_members_member,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_members_member,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_members_roleid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_members_roleid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_10 */\n",
      "iud_func_name" : "caql_iud_fn_10",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_auth_members"
   },
   "insert into pg_auth_time_constraint" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (authid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_11(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AuthTimeConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthTimeConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_11",
      "func_note" : "",
      "func_number" : "11",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_11(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/* ZERO indexes */\n\t/* Cannot obtain exclusive lock on tuple !! */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (authid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_auth_time_constraint_authid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_auth_time_constraint_authid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_11 */\n",
      "iud_func_name" : "caql_iud_fn_11",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_auth_time_constraint"
   },
   "insert into pg_authid" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 1
      },
      "foreign_key_tables" : {
         "pg_resqueue" : {
            "(oid) <- (rolresqueue)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_12(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = AuthIdRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthIdRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_12",
      "func_note" : "",
      "func_number" : "12",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_12(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tAuthIdRolnameIndexId: rolname\n\tAuthIdOidIndexId: oid\n\t*/\n\t/* pg_authid: do not get exclusive lock */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_authid primary key may be referenced in:\n\t\t  pg_auth_members (member) <- (oid)\n\t\t  pg_auth_members (roleid) <- (oid)\n\t\t  pg_auth_time_constraint (authid) <- (oid)\n\t\t  pg_class (relowner) <- (oid)\n\t\t  pg_compression (compowner) <- (oid)\n\t\t  pg_conversion (conowner) <- (oid)\n\t\t  pg_database (datdba) <- (oid)\n\t\t  pg_foreign_data_wrapper (fdwowner) <- (oid)\n\t\t  pg_foreign_server (srvowner) <- (oid)\n\t\t  pg_namespace (nspowner) <- (oid)\n\t\t  pg_opclass (opcowner) <- (oid)\n\t\t  pg_operator (oprowner) <- (oid)\n\t\t  pg_proc (proowner) <- (oid)\n\t\t  pg_remote_credentials (rcowner) <- (oid)\n\t\t  pg_tablespace (spcowner) <- (oid)\n\t\t  pg_type (typowner) <- (oid)\n\t\t  pg_user_mapping (umuser) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_resqueue (oid) <- (rolresqueue) \n\t\t*/\n\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_12 */\n",
      "iud_func_name" : "caql_iud_fn_12",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_authid"
   },
   "insert into pg_cast" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/functioncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (castfunc)" : 1
         },
         "pg_type" : {
            "(oid) <- (castsource)" : 1,
            "(oid) <- (casttarget)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_13(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = CastRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(CastRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_13",
      "func_note" : "",
      "func_number" : "13",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_13(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tCastOidIndexId: oid\n\tCastSourceTargetIndexId: castsource, casttarget\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, CastRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_cast\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  CastOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, CastRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_cast\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  CastOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_cast_castsource,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_cast_casttarget,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, CastRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_cast\",\n\t\t\t\t\t  \"castsource, casttarget\",\n\t\t\t\t\t  CastSourceTargetIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_cast_castsource,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_cast_casttarget,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, CastRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_cast\",\n\t\t\t\t\t  \"castsource, casttarget\",\n\t\t\t\t\t  CastSourceTargetIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_proc (oid) <- (castfunc)\n\t\t  pg_type (oid) <- (castsource)\n\t\t  pg_type (oid) <- (casttarget) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_cast_castfunc,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_cast_castfunc,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_cast_castsource,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_cast_castsource,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_cast_casttarget,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_cast_casttarget,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_13 */\n",
      "iud_func_name" : "caql_iud_fn_13",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_cast"
   },
   "insert into pg_class" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_am" : {
            "(oid) <- (relam)" : 1
         },
         "pg_authid" : {
            "(oid) <- (relowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (reltoastidxid)" : 1,
            "(oid) <- (reltoastrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (relnamespace)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (reltablespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (reltype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_14(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = RelationRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RelationRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_14",
      "func_note" : "",
      "func_number" : "14",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_14(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tClassOidIndexId: oid\n\tClassNameNspIndexId: relname, relnamespace\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_relname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_relnamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t  \"relname, relnamespace\",\n\t\t\t\t\t  ClassNameNspIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_relname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_relnamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t  \"relname, relnamespace\",\n\t\t\t\t\t  ClassNameNspIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_class primary key may be referenced in:\n\t\t  gp_distribution_policy (localoid) <- (oid)\n\t\t  gp_fastsequence (objid) <- (oid)\n\t\t  gp_relfile_node (relfilenode_oid) <- (oid)\n\t\t  pg_appendonly (relid) <- (oid)\n\t\t  pg_appendonly_alter_column (relid) <- (oid)\n\t\t  pg_attribute (attrelid) <- (oid)\n\t\t  pg_class (reltoastidxid) <- (oid)\n\t\t  pg_class (reltoastrelid) <- (oid)\n\t\t  pg_constraint (confrelid) <- (oid)\n\t\t  pg_constraint (conrelid) <- (oid)\n\t\t  pg_depend (classid) <- (oid)\n\t\t  pg_depend (refclassid) <- (oid)\n\t\t  pg_description (classoid) <- (oid)\n\t\t  pg_exttable (fmterrtbl) <- (oid)\n\t\t  pg_exttable (reloid) <- (oid)\n\t\t  pg_foreign_table (reloid) <- (oid)\n\t\t  pg_index (indexrelid) <- (oid)\n\t\t  pg_index (indrelid) <- (oid)\n\t\t  pg_inherits (inhparent) <- (oid)\n\t\t  pg_inherits (inhrelid) <- (oid)\n\t\t  pg_partition (parrelid) <- (oid)\n\t\t  pg_partition_rule (parchildrelid) <- (oid)\n\t\t  pg_shdepend (classid) <- (oid)\n\t\t  pg_shdepend (refclassid) <- (oid)\n\t\t  pg_shdescription (classoid) <- (oid)\n\t\t  pg_trigger (tgconstrrelid) <- (oid)\n\t\t  pg_trigger (tgrelid) <- (oid)\n\t\t  pg_type (typrelid) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_am (oid) <- (relam)\n\t\t  pg_authid (oid) <- (relowner)\n\t\t  pg_class (oid) <- (reltoastidxid)\n\t\t  pg_class (oid) <- (reltoastrelid)\n\t\t  pg_namespace (oid) <- (relnamespace)\n\t\t  pg_tablespace (oid) <- (reltablespace)\n\t\t  pg_type (oid) <- (reltype) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_relam,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AccessMethodRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_am\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AmOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_relam,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AccessMethodRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_am\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AmOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_relowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_relowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_reltoastidxid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_reltoastidxid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_reltoastrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_reltoastrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_relnamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_relnamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_reltablespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_reltablespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_class_reltype,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_class_reltype,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_14 */\n",
      "iud_func_name" : "caql_iud_fn_14",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_class"
   },
   "insert into pg_constraint" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_constraint.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (confrelid)" : 1,
            "(oid) <- (conrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (contypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_15(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_15",
      "func_note" : "",
      "func_number" : "15",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_15(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tConstraintOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConstraintRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_constraint\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ConstraintOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConstraintRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_constraint\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ConstraintOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (confrelid)\n\t\t  pg_class (oid) <- (conrelid)\n\t\t  pg_namespace (oid) <- (connamespace)\n\t\t  pg_type (oid) <- (contypid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_constraint_confrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_constraint_confrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_constraint_conrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_constraint_conrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_constraint_connamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_constraint_connamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_constraint_contypid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_constraint_contypid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_15 */\n",
      "iud_func_name" : "caql_iud_fn_15",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_constraint"
   },
   "insert into pg_conversion" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_conversion.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (conowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (conproc)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_16(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ConversionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConversionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_16",
      "func_note" : "",
      "func_number" : "16",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_16(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t3 unique indexes:\n\tConversionDefaultIndexId: connamespace, conforencoding, contoencoding, oid\n\tConversionNameNspIndexId: conname, connamespace\n\tConversionOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_connamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_conforencoding,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_contoencoding,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConversionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_conversion\",\n\t\t\t\t\t  \"connamespace, conforencoding, contoencoding, oid\",\n\t\t\t\t\t  ConversionDefaultIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_connamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_conforencoding,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_contoencoding,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConversionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_conversion\",\n\t\t\t\t\t  \"connamespace, conforencoding, contoencoding, oid\",\n\t\t\t\t\t  ConversionDefaultIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_conname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_connamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConversionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_conversion\",\n\t\t\t\t\t  \"conname, connamespace\",\n\t\t\t\t\t  ConversionNameNspIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_conname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_connamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConversionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_conversion\",\n\t\t\t\t\t  \"conname, connamespace\",\n\t\t\t\t\t  ConversionNameNspIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConversionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_conversion\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ConversionOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ConversionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_conversion\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ConversionOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (conowner)\n\t\t  pg_namespace (oid) <- (connamespace)\n\t\t  pg_proc (oid) <- (conproc) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_conowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_conowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_connamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_connamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_conversion_conproc,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_conversion_conproc,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_16 */\n",
      "iud_func_name" : "caql_iud_fn_16",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_conversion"
   },
   "insert into pg_database" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/dbcommands.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (datdba)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (dattablespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_17(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = DatabaseRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DatabaseRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_17",
      "func_note" : "",
      "func_number" : "17",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_17(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tDatabaseNameIndexId: datname\n\tDatabaseOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_database_datname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, DatabaseRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_database\",\n\t\t\t\t\t  \"datname\",\n\t\t\t\t\t  DatabaseNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_database_datname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, DatabaseRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_database\",\n\t\t\t\t\t  \"datname\",\n\t\t\t\t\t  DatabaseNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, DatabaseRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_database\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  DatabaseOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, DatabaseRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_database\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  DatabaseOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_database primary key may be referenced in:\n\t\t  pg_shdepend (dbid) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (datdba)\n\t\t  pg_tablespace (oid) <- (dattablespace) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_database_datdba,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_database_datdba,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_database_dattablespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_database_dattablespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_17 */\n",
      "iud_func_name" : "caql_iud_fn_17",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_database"
   },
   "insert into pg_depend" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_depend.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_18(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = DependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_18",
      "func_note" : "",
      "func_number" : "18",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_18(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\tZERO unique indexes\n\t*/\n\t/* Cannot obtain exclusive lock on tuple !! */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (classid)\n\t\t  pg_class (oid) <- (refclassid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_depend_classid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_depend_classid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_depend_refclassid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_depend_refclassid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_18 */\n",
      "iud_func_name" : "caql_iud_fn_18",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_depend"
   },
   "insert into pg_description" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_19(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = DescriptionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DescriptionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_19",
      "func_note" : "",
      "func_number" : "19",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_19(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tDescriptionObjIndexId: objoid, classoid, objsubid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_description_objoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_description_classoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_description_objsubid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, DescriptionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_description\",\n\t\t\t\t\t  \"objoid, classoid, objsubid\",\n\t\t\t\t\t  DescriptionObjIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_description_objoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_description_classoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_description_objsubid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, DescriptionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_description\",\n\t\t\t\t\t  \"objoid, classoid, objsubid\",\n\t\t\t\t\t  DescriptionObjIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (classoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_description_classoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_description_classoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_19 */\n",
      "iud_func_name" : "caql_iud_fn_19",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_description"
   },
   "insert into pg_extprotocol" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_extprotocol.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (ptcreadfn)" : 1,
            "(oid) <- (ptcvalidatorfn)" : 1,
            "(oid) <- (ptcwritefn)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_20(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ExtprotocolRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ExtprotocolRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_20",
      "func_note" : "",
      "func_number" : "20",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_20(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tExtprotocolOidIndexId: oid\n\tExtprotocolPtcnameIndexId: ptcname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ExtprotocolRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_extprotocol\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ExtprotocolOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ExtprotocolRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_extprotocol\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ExtprotocolOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_extprotocol_ptcname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ExtprotocolRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_extprotocol\",\n\t\t\t\t\t  \"ptcname\",\n\t\t\t\t\t  ExtprotocolPtcnameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_extprotocol_ptcname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ExtprotocolRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_extprotocol\",\n\t\t\t\t\t  \"ptcname\",\n\t\t\t\t\t  ExtprotocolPtcnameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_proc (oid) <- (ptcreadfn)\n\t\t  pg_proc (oid) <- (ptcvalidatorfn)\n\t\t  pg_proc (oid) <- (ptcwritefn) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_extprotocol_ptcreadfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_extprotocol_ptcreadfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_extprotocol_ptcvalidatorfn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_extprotocol_ptcvalidatorfn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_extprotocol_ptcwritefn,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_extprotocol_ptcwritefn,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_20 */\n",
      "iud_func_name" : "caql_iud_fn_20",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_extprotocol"
   },
   "insert into pg_exttable" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_exttable.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (fmterrtbl)" : 1,
            "(oid) <- (reloid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_21(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ExtTableRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ExtTableRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_21",
      "func_note" : "",
      "func_number" : "21",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_21(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tExtTableReloidIndexId: reloid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_exttable_reloid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ExtTableRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_exttable\",\n\t\t\t\t\t  \"reloid\",\n\t\t\t\t\t  ExtTableReloidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_exttable_reloid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ExtTableRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_exttable\",\n\t\t\t\t\t  \"reloid\",\n\t\t\t\t\t  ExtTableReloidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (fmterrtbl)\n\t\t  pg_class (oid) <- (reloid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_exttable_fmterrtbl,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_exttable_fmterrtbl,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_exttable_reloid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_exttable_reloid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_21 */\n",
      "iud_func_name" : "caql_iud_fn_21",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_exttable"
   },
   "insert into pg_filespace" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/filespace.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_22(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = FileSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FileSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_22",
      "func_note" : "",
      "func_number" : "22",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_22(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tFilespaceOidIndexId: oid\n\tFilespaceNameIndexId: fsname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  FilespaceOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  FilespaceOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_filespace_fsname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t  \"fsname\",\n\t\t\t\t\t  FilespaceNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_filespace_fsname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t  \"fsname\",\n\t\t\t\t\t  FilespaceNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_filespace primary key may be referenced in:\n\t\t  pg_filespace_entry (fsefsoid) <- (oid)\n\t\t  pg_tablespace (spcfsoid) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE: pg_filespace does not have fk reference to any table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_22 */\n",
      "iud_func_name" : "caql_iud_fn_22",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_filespace"
   },
   "insert into pg_filespace_entry" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/filespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_filespace" : {
            "(oid) <- (fsefsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_23(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = FileSpaceEntryRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FileSpaceEntryRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_23",
      "func_note" : "",
      "func_number" : "23",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_23(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tFileSpaceEntryFsefsoidFsedbidIndexId: fsefsoid, fsedbid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_filespace_entry_fsefsoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_filespace_entry_fsedbid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, FileSpaceEntryRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_filespace_entry\",\n\t\t\t\t\t  \"fsefsoid, fsedbid\",\n\t\t\t\t\t  FileSpaceEntryFsefsoidFsedbidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_filespace_entry_fsefsoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_filespace_entry_fsedbid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, FileSpaceEntryRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_filespace_entry\",\n\t\t\t\t\t  \"fsefsoid, fsedbid\",\n\t\t\t\t\t  FileSpaceEntryFsefsoidFsedbidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_filespace (oid) <- (fsefsoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_filespace_entry_fsefsoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  FilespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_filespace_entry_fsefsoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  FilespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_23 */\n",
      "iud_func_name" : "caql_iud_fn_23",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_filespace_entry"
   },
   "insert into pg_foreign_data_wrapper" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (fdwowner)" : 1
         },
         "pg_proc" : {
            "(oid) <- (fdwvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_24(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ForeignDataWrapperRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignDataWrapperRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_24",
      "func_note" : "",
      "func_number" : "24",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_24(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tForeignDataWrapperOidIndexId: oid\n\tForeignDataWrapperNameIndexId: fdwname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignDataWrapperRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_foreign_data_wrapper\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ForeignDataWrapperOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignDataWrapperRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_foreign_data_wrapper\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ForeignDataWrapperOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_data_wrapper_fdwname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignDataWrapperRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_foreign_data_wrapper\",\n\t\t\t\t\t  \"fdwname\",\n\t\t\t\t\t  ForeignDataWrapperNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_data_wrapper_fdwname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignDataWrapperRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_foreign_data_wrapper\",\n\t\t\t\t\t  \"fdwname\",\n\t\t\t\t\t  ForeignDataWrapperNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_foreign_data_wrapper primary key may be referenced in:\n\t\t  pg_foreign_server (srvfdw) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (fdwowner)\n\t\t  pg_proc (oid) <- (fdwvalidator) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_data_wrapper_fdwowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_data_wrapper_fdwowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_data_wrapper_fdwvalidator,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_data_wrapper_fdwvalidator,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_24 */\n",
      "iud_func_name" : "caql_iud_fn_24",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_foreign_data_wrapper"
   },
   "insert into pg_foreign_server" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (srvowner)" : 1
         },
         "pg_foreign_data_wrapper" : {
            "(oid) <- (srvfdw)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_25(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ForeignServerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignServerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_25",
      "func_note" : "",
      "func_number" : "25",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_25(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tForeignServerOidIndexId: oid\n\tForeignServerNameIndexId: srvname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ForeignServerOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ForeignServerOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_server_srvname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t  \"srvname\",\n\t\t\t\t\t  ForeignServerNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_server_srvname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t  \"srvname\",\n\t\t\t\t\t  ForeignServerNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_foreign_server primary key may be referenced in:\n\t\t  pg_foreign_table (server) <- (oid)\n\t\t  pg_user_mapping (umserver) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (srvowner)\n\t\t  pg_foreign_data_wrapper (oid) <- (srvfdw) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_server_srvowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_server_srvowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_server_srvfdw,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ForeignDataWrapperRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_foreign_data_wrapper\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ForeignDataWrapperOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_server_srvfdw,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ForeignDataWrapperRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_foreign_data_wrapper\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ForeignDataWrapperOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_25 */\n",
      "iud_func_name" : "caql_iud_fn_25",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_foreign_server"
   },
   "insert into pg_foreign_table" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (reloid)" : 1
         },
         "pg_foreign_server" : {
            "(oid) <- (server)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_26(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ForeignTableRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignTableRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_26",
      "func_note" : "",
      "func_number" : "26",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_26(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tForeignTableRelOidIndexId: reloid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_table_reloid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignTableRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_foreign_table\",\n\t\t\t\t\t  \"reloid\",\n\t\t\t\t\t  ForeignTableRelOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_table_reloid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ForeignTableRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_foreign_table\",\n\t\t\t\t\t  \"reloid\",\n\t\t\t\t\t  ForeignTableRelOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (reloid)\n\t\t  pg_foreign_server (oid) <- (server) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_table_reloid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_table_reloid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_foreign_table_server,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ForeignServerOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_foreign_table_server,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ForeignServerOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_26 */\n",
      "iud_func_name" : "caql_iud_fn_26",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_foreign_table"
   },
   "insert into pg_index" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/index.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (indexrelid)" : 1,
            "(oid) <- (indrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (indclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_27(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = IndexRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(IndexRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_27",
      "func_note" : "",
      "func_number" : "27",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_27(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tIndexRelidIndexId: indexrelid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_index_indexrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, IndexRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_index\",\n\t\t\t\t\t  \"indexrelid\",\n\t\t\t\t\t  IndexRelidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_index_indexrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, IndexRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_index\",\n\t\t\t\t\t  \"indexrelid\",\n\t\t\t\t\t  IndexRelidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (indexrelid)\n\t\t  pg_class (oid) <- (indrelid)\n\t\t  pg_opclass (oid) <- (indclass) [vector] \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_index_indexrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_index_indexrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_index_indrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_index_indrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oidvector */\n\t\t\td = caql_getattr_internal(pCtx, newtup, \n\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetPointer(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\tnewhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oidvector */\n\t\t\td = caql_getattr_internal(pCtx, oldtup, \n\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetPointer(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\toldhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n} /* end caql_iud_fn_27 */\n",
      "iud_func_name" : "caql_iud_fn_27",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_index"
   },
   "insert into pg_inherits" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (inhparent)" : 1,
            "(oid) <- (inhrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_28(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = InheritsRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(InheritsRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_28",
      "func_note" : "",
      "func_number" : "28",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_28(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tInheritsRelidSeqnoIndexId: inhrelid, inhseqno\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_inherits_inhrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_inherits_inhseqno,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, InheritsRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_inherits\",\n\t\t\t\t\t  \"inhrelid, inhseqno\",\n\t\t\t\t\t  InheritsRelidSeqnoIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_inherits_inhrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_inherits_inhseqno,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, InheritsRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_inherits\",\n\t\t\t\t\t  \"inhrelid, inhseqno\",\n\t\t\t\t\t  InheritsRelidSeqnoIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (inhparent)\n\t\t  pg_class (oid) <- (inhrelid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_inherits_inhparent,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_inherits_inhparent,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_inherits_inhrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_inherits_inhrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_28 */\n",
      "iud_func_name" : "caql_iud_fn_28",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_inherits"
   },
   "insert into pg_language" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/proclang.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (lanplcallfoid)" : 1,
            "(oid) <- (lanvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_29(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = LanguageRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(LanguageRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_29",
      "func_note" : "",
      "func_number" : "29",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_29(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tLanguageNameIndexId: lanname\n\tLanguageOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_language_lanname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, LanguageRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_language\",\n\t\t\t\t\t  \"lanname\",\n\t\t\t\t\t  LanguageNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_language_lanname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, LanguageRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_language\",\n\t\t\t\t\t  \"lanname\",\n\t\t\t\t\t  LanguageNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, LanguageRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_language\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  LanguageOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, LanguageRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_language\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  LanguageOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_language primary key may be referenced in:\n\t\t  pg_proc (prolang) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_proc (oid) <- (lanplcallfoid)\n\t\t  pg_proc (oid) <- (lanvalidator) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_language_lanplcallfoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_language_lanplcallfoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_language_lanvalidator,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_language_lanvalidator,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_29 */\n",
      "iud_func_name" : "caql_iud_fn_29",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_language"
   },
   "insert into pg_namespace" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_namespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (nspowner)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_30(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = NamespaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(NamespaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_30",
      "func_note" : "",
      "func_number" : "30",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_30(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tNamespaceNspnameNspdboidIndexId: nspname, nspdboid\n\tNamespaceOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_namespace_nspname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_namespace_nspdboid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t  \"nspname, nspdboid\",\n\t\t\t\t\t  NamespaceNspnameNspdboidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_namespace_nspname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_namespace_nspdboid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t  \"nspname, nspdboid\",\n\t\t\t\t\t  NamespaceNspnameNspdboidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_namespace primary key may be referenced in:\n\t\t  pg_class (relnamespace) <- (oid)\n\t\t  pg_constraint (connamespace) <- (oid)\n\t\t  pg_conversion (connamespace) <- (oid)\n\t\t  pg_opclass (opcnamespace) <- (oid)\n\t\t  pg_operator (oprnamespace) <- (oid)\n\t\t  pg_proc (pronamespace) <- (oid)\n\t\t  pg_type (typnamespace) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (nspowner) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_namespace_nspowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_namespace_nspowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_30 */\n",
      "iud_func_name" : "caql_iud_fn_30",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_namespace"
   },
   "insert into pg_opclass" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/opclasscmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (opcowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (opcnamespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_31(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = OperatorClassRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorClassRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_31",
      "func_note" : "",
      "func_number" : "31",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_31(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tOpclassAmNameNspIndexId: opcamid, opcname, opcnamespace\n\tOpclassOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_opclass_opcamid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_opclass_opcname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_opclass_opcnamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t  \"opcamid, opcname, opcnamespace\",\n\t\t\t\t\t  OpclassAmNameNspIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_opclass_opcamid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_opclass_opcname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_opclass_opcnamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t  \"opcamid, opcname, opcnamespace\",\n\t\t\t\t\t  OpclassAmNameNspIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_opclass primary key may be referenced in:\n\t\t  pg_amop (amopclaid) <- (oid)\n\t\t  pg_amproc (amopclaid) <- (oid)\n\t\t  pg_index (indclass) <- (oid) [vector]\n\t\t  pg_partition (parclass) <- (oid) [vector] \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (opcowner)\n\t\t  pg_namespace (oid) <- (opcnamespace) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_opclass_opcowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_opclass_opcowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_opclass_opcnamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_opclass_opcnamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_31 */\n",
      "iud_func_name" : "caql_iud_fn_31",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_opclass"
   },
   "insert into pg_operator" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_operator.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_32(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_32",
      "func_note" : "",
      "func_number" : "32",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_32(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tOperatorOidIndexId: oid\n\tOperatorNameNspIndexId: oprname, oprleft, oprright, oprnamespace\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprleft,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprright,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprnamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t  \"oprname, oprleft, oprright, oprnamespace\",\n\t\t\t\t\t  OperatorNameNspIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprleft,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprright,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprnamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t  \"oprname, oprleft, oprright, oprnamespace\",\n\t\t\t\t\t  OperatorNameNspIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_operator primary key may be referenced in:\n\t\t  pg_aggregate (aggsortop) <- (oid)\n\t\t  pg_amop (amopopr) <- (oid)\n\t\t  pg_operator (oprcom) <- (oid)\n\t\t  pg_operator (oprgtcmpop) <- (oid)\n\t\t  pg_operator (oprlsortop) <- (oid)\n\t\t  pg_operator (oprltcmpop) <- (oid)\n\t\t  pg_operator (oprnegate) <- (oid)\n\t\t  pg_operator (oprrsortop) <- (oid)\n\t\t  pg_statistic (staop1) <- (oid)\n\t\t  pg_statistic (staop2) <- (oid)\n\t\t  pg_statistic (staop3) <- (oid)\n\t\t  pg_statistic (staop4) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (oprowner)\n\t\t  pg_namespace (oid) <- (oprnamespace)\n\t\t  pg_operator (oid) <- (oprcom)\n\t\t  pg_operator (oid) <- (oprgtcmpop)\n\t\t  pg_operator (oid) <- (oprlsortop)\n\t\t  pg_operator (oid) <- (oprltcmpop)\n\t\t  pg_operator (oid) <- (oprnegate)\n\t\t  pg_operator (oid) <- (oprrsortop)\n\t\t  pg_proc (oid) <- (oprcode)\n\t\t  pg_proc (oid) <- (oprjoin)\n\t\t  pg_proc (oid) <- (oprrest)\n\t\t  pg_type (oid) <- (oprleft)\n\t\t  pg_type (oid) <- (oprresult)\n\t\t  pg_type (oid) <- (oprright) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprnamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprnamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprcom,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprcom,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprgtcmpop,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprgtcmpop,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprlsortop,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprlsortop,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprltcmpop,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprltcmpop,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprnegate,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprnegate,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprrsortop,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprrsortop,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprcode,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprcode,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprjoin,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprjoin,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprrest,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprrest,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprleft,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprleft,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprresult,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprresult,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_operator_oprright,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_operator_oprright,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_32 */\n",
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_operator"
   },
   "insert into pg_partition" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (parclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_33(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = PartitionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_33",
      "func_note" : "",
      "func_number" : "33",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_33(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tPartitionOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, PartitionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_partition\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  PartitionOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, PartitionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_partition\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  PartitionOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_partition primary key may be referenced in:\n\t\t  pg_partition_encoding (parencoid) <- (oid)\n\t\t  pg_partition_rule (paroid) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (parrelid)\n\t\t  pg_opclass (oid) <- (parclass) [vector] \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_parrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_parrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oidvector */\n\t\t\td = caql_getattr_internal(pCtx, newtup, \n\t\t\t\t\t\t\t Anum_pg_partition_parclass,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetPointer(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\tnewhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oidvector */\n\t\t\td = caql_getattr_internal(pCtx, oldtup, \n\t\t\t\t\t\t\t Anum_pg_partition_parclass,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetPointer(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\toldhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, OperatorClassRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t\t\t  \"pg_opclass\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  OpclassOidIndexId,\n\t\t\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n} /* end caql_iud_fn_33 */\n",
      "iud_func_name" : "caql_iud_fn_33",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition"
   },
   "insert into pg_partition_encoding" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 1
      },
      "foreign_key_tables" : {
         "pg_partition" : {
            "(oid) <- (parencoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_34(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = PartitionEncodingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionEncodingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_34",
      "func_note" : "",
      "func_number" : "34",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_34(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tPartitionEncodingParencoidAttnumIndexId: parencoid, parencattnum\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_encoding_parencoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_encoding_parencattnum,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, PartitionEncodingRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_partition_encoding\",\n\t\t\t\t\t  \"parencoid, parencattnum\",\n\t\t\t\t\t  PartitionEncodingParencoidAttnumIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_encoding_parencoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_encoding_parencattnum,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, PartitionEncodingRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_partition_encoding\",\n\t\t\t\t\t  \"parencoid, parencattnum\",\n\t\t\t\t\t  PartitionEncodingParencoidAttnumIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_partition (oid) <- (parencoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_encoding_parencoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, PartitionRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_partition\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  PartitionOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_encoding_parencoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, PartitionRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_partition\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  PartitionOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_34 */\n",
      "iud_func_name" : "caql_iud_fn_34",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_encoding"
   },
   "insert into pg_partition_rule" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_35(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_35",
      "func_note" : "",
      "func_number" : "35",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_35(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tPartitionRuleOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, PartitionRuleRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_partition_rule\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  PartitionRuleOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, PartitionRuleRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_partition_rule\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  PartitionRuleOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_partition_rule primary key may be referenced in:\n\t\t  pg_partition_rule (parparentrule) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (parchildrelid)\n\t\t  pg_partition (oid) <- (paroid)\n\t\t  pg_partition_rule (oid) <- (parparentrule)\n\t\t  pg_tablespace (oid) <- (partemplatespace) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_rule_parchildrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_rule_parchildrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_rule_paroid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, PartitionRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_partition\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  PartitionOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_rule_paroid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, PartitionRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_partition\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  PartitionOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_rule_parparentrule,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, PartitionRuleRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_partition_rule\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  PartitionRuleOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_rule_parparentrule,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, PartitionRuleRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_partition_rule\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  PartitionRuleOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_partition_rule_partemplatespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_partition_rule_partemplatespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_35 */\n",
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_rule"
   },
   "insert into pg_proc" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_proc.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (proowner)" : 1
         },
         "pg_language" : {
            "(oid) <- (prolang)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (pronamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (proallargtypes) [vector]" : 1,
            "(oid) <- (proargtypes) [vector]" : 1,
            "(oid) <- (prorettype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_36(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_36",
      "func_note" : "",
      "func_number" : "36",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_36(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tProcedureOidIndexId: oid\n\tProcedureNameArgsNspIndexId: proname, proargtypes, pronamespace\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_proname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_proargtypes,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDVECTOROID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_pronamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t  \"proname, proargtypes, pronamespace\",\n\t\t\t\t\t  ProcedureNameArgsNspIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_proname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_proargtypes,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDVECTOROID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_pronamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t  \"proname, proargtypes, pronamespace\",\n\t\t\t\t\t  ProcedureNameArgsNspIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_proc primary key may be referenced in:\n\t\t  pg_aggregate (aggfinalfn) <- (oid)\n\t\t  pg_aggregate (aggfnoid) <- (oid)\n\t\t  pg_aggregate (agginvprelimfn) <- (oid)\n\t\t  pg_aggregate (agginvtransfn) <- (oid)\n\t\t  pg_aggregate (aggprelimfn) <- (oid)\n\t\t  pg_aggregate (aggtransfn) <- (oid)\n\t\t  pg_am (ambeginscan) <- (oid)\n\t\t  pg_am (ambuild) <- (oid)\n\t\t  pg_am (ambulkdelete) <- (oid)\n\t\t  pg_am (amcostestimate) <- (oid)\n\t\t  pg_am (amendscan) <- (oid)\n\t\t  pg_am (amgetmulti) <- (oid)\n\t\t  pg_am (amgettuple) <- (oid)\n\t\t  pg_am (aminsert) <- (oid)\n\t\t  pg_am (ammarkpos) <- (oid)\n\t\t  pg_am (amoptions) <- (oid)\n\t\t  pg_am (amrescan) <- (oid)\n\t\t  pg_am (amrestrpos) <- (oid)\n\t\t  pg_am (amvacuumcleanup) <- (oid)\n\t\t  pg_amproc (amproc) <- (oid)\n\t\t  pg_cast (castfunc) <- (oid)\n\t\t  pg_compression (compcompressor) <- (oid)\n\t\t  pg_compression (compconstructor) <- (oid)\n\t\t  pg_compression (compdecompressor) <- (oid)\n\t\t  pg_compression (compdestructor) <- (oid)\n\t\t  pg_compression (compvalidator) <- (oid)\n\t\t  pg_conversion (conproc) <- (oid)\n\t\t  pg_extprotocol (ptcreadfn) <- (oid)\n\t\t  pg_extprotocol (ptcvalidatorfn) <- (oid)\n\t\t  pg_extprotocol (ptcwritefn) <- (oid)\n\t\t  pg_foreign_data_wrapper (fdwvalidator) <- (oid)\n\t\t  pg_language (lanplcallfoid) <- (oid)\n\t\t  pg_language (lanvalidator) <- (oid)\n\t\t  pg_operator (oprcode) <- (oid)\n\t\t  pg_operator (oprjoin) <- (oid)\n\t\t  pg_operator (oprrest) <- (oid)\n\t\t  pg_proc_callback (procallback) <- (oid)\n\t\t  pg_proc_callback (profnoid) <- (oid)\n\t\t  pg_trigger (tgfoid) <- (oid)\n\t\t  pg_type (typanalyze) <- (oid)\n\t\t  pg_type (typinput) <- (oid)\n\t\t  pg_type (typoutput) <- (oid)\n\t\t  pg_type (typreceive) <- (oid)\n\t\t  pg_type (typsend) <- (oid)\n\t\t  pg_window (winfinfunc) <- (oid)\n\t\t  pg_window (winfnoid) <- (oid)\n\t\t  pg_window (winfunc) <- (oid)\n\t\t  pg_window (winprefunc) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (proowner)\n\t\t  pg_language (oid) <- (prolang)\n\t\t  pg_namespace (oid) <- (pronamespace)\n\t\t  pg_type (oid) <- (proallargtypes) [vector]\n\t\t  pg_type (oid) <- (proargtypes) [vector]\n\t\t  pg_type (oid) <- (prorettype) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_proowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_proowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_prolang,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, LanguageRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_language\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  LanguageOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_prolang,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, LanguageRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_language\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  LanguageOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_pronamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_pronamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oid array */\n\t\t\td = caql_getattr_internal(pCtx, newtup, \n\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetArrayTypeP(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\tnewhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oid array */\n\t\t\td = caql_getattr_internal(pCtx, oldtup, \n\t\t\t\t\t\t\t Anum_pg_proc_proallargtypes,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetArrayTypeP(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\toldhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oidvector */\n\t\t\td = caql_getattr_internal(pCtx, newtup, \n\t\t\t\t\t\t\t Anum_pg_proc_proargtypes,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetPointer(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\tnewhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\t/* NOTE: special case of oidvector */\n\t\t\td = caql_getattr_internal(pCtx, oldtup, \n\t\t\t\t\t\t\t Anum_pg_proc_proargtypes,\n\t\t\t\t\t\t\t &isnull);\n\t\t\n\t\t\tArrayType *oidarr = isnull ? NULL : \n\t\t\t\t\t\t\t\t(ArrayType *) DatumGetPointer(d);\n\t\t\n\t\t\t/* must be a 1 dimensional array of oid \n\t\t\t  (either oidvector or oid array) \n\t\t\t  */\n\t\t\tif (!isnull && oidarr)\n\t\t\t{\n\t\t\t\tAssert((ARR_NDIM(oidarr) == 1) &&\n\t\t\t\t\t   (ARR_ELEMTYPE(oidarr) == OIDOID));\n\t\t\n\t\t\t\tOid *ovp = (Oid *)ARR_DATA_PTR(oidarr);\n\t\t\n\t\t\t\t/* lock every oid in the array */\n\t\t\t\tfor (int ii=0; ii < ARR_DIMS(oidarr)[0]; ii++)\n\t\t\t\t{\n\t\t\t\t\toldhash = ovp[ii];\n\t\t\n\t\t\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_prorettype,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_prorettype,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_36 */\n",
      "iud_func_name" : "caql_iud_fn_36",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_proc"
   },
   "insert into pg_proc_callback" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_proc_callback.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (procallback)" : 1,
            "(oid) <- (profnoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_37(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = ProcCallbackRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcCallbackRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_37",
      "func_note" : "",
      "func_number" : "37",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_37(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tProcCallbackProfnoidPromethodIndexId: profnoid, promethod\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_callback_profnoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_callback_promethod,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, CHAROID);\n\t\n\t\tcaql_lockwell(pCtx, ProcCallbackRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_proc_callback\",\n\t\t\t\t\t  \"profnoid, promethod\",\n\t\t\t\t\t  ProcCallbackProfnoidPromethodIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_callback_profnoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_callback_promethod,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, CHAROID);\n\t\n\t\tcaql_lockwell(pCtx, ProcCallbackRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_proc_callback\",\n\t\t\t\t\t  \"profnoid, promethod\",\n\t\t\t\t\t  ProcCallbackProfnoidPromethodIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_proc (oid) <- (procallback)\n\t\t  pg_proc (oid) <- (profnoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_callback_procallback,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_callback_procallback,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_proc_callback_profnoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_proc_callback_profnoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_37 */\n",
      "iud_func_name" : "caql_iud_fn_37",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_proc_callback"
   },
   "insert into pg_shdepend" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_shdepend.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         },
         "pg_database" : {
            "(oid) <- (dbid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_38(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = SharedDependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(SharedDependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_38",
      "func_note" : "",
      "func_number" : "38",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_38(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\tZERO unique indexes\n\t*/\n\t/* Cannot obtain exclusive lock on tuple !! */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (classid)\n\t\t  pg_class (oid) <- (refclassid)\n\t\t  pg_database (oid) <- (dbid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_shdepend_classid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_shdepend_classid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_shdepend_refclassid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_shdepend_refclassid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_shdepend_dbid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, DatabaseRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_database\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  DatabaseOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_shdepend_dbid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, DatabaseRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_database\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  DatabaseOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_38 */\n",
      "iud_func_name" : "caql_iud_fn_38",
      "num_del_ops" : 0,
      "num_ins_ops" : 2,
      "num_upd_ops" : 0,
      "tablename" : "pg_shdepend"
   },
   "insert into pg_shdescription" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_39(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = SharedDescriptionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(SharedDescriptionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_39",
      "func_note" : "",
      "func_number" : "39",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_39(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tSharedDescriptionObjIndexId: objoid, classoid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_shdescription_objoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_shdescription_classoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, SharedDescriptionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_shdescription\",\n\t\t\t\t\t  \"objoid, classoid\",\n\t\t\t\t\t  SharedDescriptionObjIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_shdescription_objoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_shdescription_classoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, SharedDescriptionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_shdescription\",\n\t\t\t\t\t  \"objoid, classoid\",\n\t\t\t\t\t  SharedDescriptionObjIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (classoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_shdescription_classoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_shdescription_classoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_39 */\n",
      "iud_func_name" : "caql_iud_fn_39",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_shdescription"
   },
   "insert into pg_stat_last_operation" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (stasysid)" : 1
         },
         "pg_class" : {
            "(oid) <- (classid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_40(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = StatLastOpRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatLastOpRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_40",
      "func_note" : "",
      "func_number" : "40",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_40(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tStatLastOpClassidObjidStaactionnameIndexId: classid, objid, staactionname\n\t*/\n\t/* pg_stat_last_operation: do not get exclusive lock */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE/DELETE: no references\n\t\t   pg_stat_last_operation is unrelated to any other table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_40 */\n",
      "iud_func_name" : "caql_iud_fn_40",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_stat_last_operation"
   },
   "insert into pg_stat_last_shoperation" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (stasysid)" : 1
         },
         "pg_class" : {
            "(oid) <- (classid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_41(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = StatLastShOpRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatLastShOpRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_41",
      "func_note" : "",
      "func_number" : "41",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_41(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tStatLastShOpClassidObjidStaactionnameIndexId: classid, objid, staactionname\n\t*/\n\t/* pg_stat_last_shoperation: do not get exclusive lock */\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE/DELETE: no references\n\t\t   pg_stat_last_shoperation is unrelated to any other table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_41 */\n",
      "iud_func_name" : "caql_iud_fn_41",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_stat_last_shoperation"
   },
   "insert into pg_tablespace" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (spcowner)" : 1
         },
         "pg_filespace" : {
            "(oid) <- (spcfsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_42(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = TableSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TableSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_42",
      "func_note" : "",
      "func_number" : "42",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_42(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tTablespaceOidIndexId: oid\n\tTablespaceNameIndexId: spcname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  TablespaceOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_tablespace_spcname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t  \"spcname\",\n\t\t\t\t\t  TablespaceNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_tablespace_spcname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, TableSpaceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_tablespace\",\n\t\t\t\t\t  \"spcname\",\n\t\t\t\t\t  TablespaceNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_tablespace primary key may be referenced in:\n\t\t  pg_class (reltablespace) <- (oid)\n\t\t  pg_database (dattablespace) <- (oid)\n\t\t  pg_partition_rule (partemplatespace) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (spcowner)\n\t\t  pg_filespace (oid) <- (spcfsoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_tablespace_spcowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_tablespace_spcowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_tablespace_spcfsoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  FilespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_tablespace_spcfsoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, FileSpaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_filespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  FilespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_42 */\n",
      "iud_func_name" : "caql_iud_fn_42",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_tablespace"
   },
   "insert into pg_trigger" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/trigger.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_43(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_43",
      "func_note" : "",
      "func_number" : "43",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_43(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tTriggerRelidNameIndexId: tgrelid, tgname\n\tTriggerOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_trigger_tgrelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_trigger_tgname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, TriggerRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_trigger\",\n\t\t\t\t\t  \"tgrelid, tgname\",\n\t\t\t\t\t  TriggerRelidNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_trigger_tgrelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_trigger_tgname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, TriggerRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_trigger\",\n\t\t\t\t\t  \"tgrelid, tgname\",\n\t\t\t\t\t  TriggerRelidNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TriggerRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_trigger\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  TriggerOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TriggerRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_trigger\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  TriggerOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (tgconstrrelid)\n\t\t  pg_class (oid) <- (tgrelid)\n\t\t  pg_proc (oid) <- (tgfoid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_trigger_tgconstrrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_trigger_tgconstrrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_trigger_tgrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_trigger_tgrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_trigger_tgfoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_trigger_tgfoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_43 */\n",
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_trigger"
   },
   "insert into pg_type" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_type.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (typowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (typrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (typnamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (typanalyze)" : 1,
            "(oid) <- (typinput)" : 1,
            "(oid) <- (typoutput)" : 1,
            "(oid) <- (typreceive)" : 1,
            "(oid) <- (typsend)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_44(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = TypeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_44",
      "func_note" : "",
      "func_number" : "44",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_44(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tTypeOidIndexId: oid\n\tTypeNameNspIndexId: typname, typnamespace\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typnamespace,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t  \"typname, typnamespace\",\n\t\t\t\t\t  TypeNameNspIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typnamespace,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t  \"typname, typnamespace\",\n\t\t\t\t\t  TypeNameNspIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_type primary key may be referenced in:\n\t\t  pg_aggregate (aggtranstype) <- (oid)\n\t\t  pg_amop (amopsubtype) <- (oid)\n\t\t  pg_amproc (amprocsubtype) <- (oid)\n\t\t  pg_attribute (atttypid) <- (oid)\n\t\t  pg_cast (castsource) <- (oid)\n\t\t  pg_cast (casttarget) <- (oid)\n\t\t  pg_class (reltype) <- (oid)\n\t\t  pg_constraint (contypid) <- (oid)\n\t\t  pg_operator (oprleft) <- (oid)\n\t\t  pg_operator (oprresult) <- (oid)\n\t\t  pg_operator (oprright) <- (oid)\n\t\t  pg_proc (proallargtypes) <- (oid) [vector]\n\t\t  pg_proc (proargtypes) <- (oid) [vector]\n\t\t  pg_proc (prorettype) <- (oid)\n\t\t  pg_type_encoding (typid) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (typowner)\n\t\t  pg_class (oid) <- (typrelid)\n\t\t  pg_namespace (oid) <- (typnamespace)\n\t\t  pg_proc (oid) <- (typanalyze)\n\t\t  pg_proc (oid) <- (typinput)\n\t\t  pg_proc (oid) <- (typoutput)\n\t\t  pg_proc (oid) <- (typreceive)\n\t\t  pg_proc (oid) <- (typsend) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typrelid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typrelid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typnamespace,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typnamespace,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, NamespaceRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_namespace\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  NamespaceOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typanalyze,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typanalyze,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typinput,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typinput,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typoutput,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typoutput,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typreceive,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typreceive,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_typsend,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_typsend,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_44 */\n",
      "iud_func_name" : "caql_iud_fn_44",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_type"
   },
   "insert into pg_type_encoding" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_type.c" : 1
      },
      "foreign_key_tables" : {
         "pg_type" : {
            "(oid) <- (typid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_45(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = TypeEncodingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeEncodingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_45",
      "func_note" : "",
      "func_number" : "45",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_45(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tTypeEncodingTypidIndexId: typid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_encoding_typid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TypeEncodingRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_type_encoding\",\n\t\t\t\t\t  \"typid\",\n\t\t\t\t\t  TypeEncodingTypidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_encoding_typid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, TypeEncodingRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_type_encoding\",\n\t\t\t\t\t  \"typid\",\n\t\t\t\t\t  TypeEncodingTypidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_type (oid) <- (typid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_type_encoding_typid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_type_encoding_typid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, TypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_type\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  TypeOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_45 */\n",
      "iud_func_name" : "caql_iud_fn_45",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_type_encoding"
   },
   "insert into pg_user_mapping" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (umuser)" : 1
         },
         "pg_foreign_server" : {
            "(oid) <- (umserver)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_46(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tRelation\trel;\n\n\tpCtx->cq_relationId = UserMappingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(UserMappingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\treturn NULL; /* XXX XXX: don't init scan */\n}\n",
      "func_name" : "caql_basic_fn_46",
      "func_note" : "",
      "func_number" : "46",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_46(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tUserMappingOidIndexId: oid\n\tUserMappingUserServerIndexId: umuser, umserver\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, UserMappingRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_user_mapping\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  UserMappingOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, UserMappingRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_user_mapping\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  UserMappingOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_user_mapping_umuser,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_user_mapping_umserver,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, UserMappingRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_user_mapping\",\n\t\t\t\t\t  \"umuser, umserver\",\n\t\t\t\t\t  UserMappingUserServerIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_user_mapping_umuser,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_user_mapping_umserver,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, UserMappingRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_user_mapping\",\n\t\t\t\t\t  \"umuser, umserver\",\n\t\t\t\t\t  UserMappingUserServerIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (umuser)\n\t\t  pg_foreign_server (oid) <- (umserver) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_user_mapping_umuser,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_user_mapping_umuser,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_user_mapping_umserver,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ForeignServerOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_user_mapping_umserver,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ForeignServerRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_foreign_server\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ForeignServerOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_46 */\n",
      "iud_func_name" : "caql_iud_fn_46",
      "num_del_ops" : 0,
      "num_ins_ops" : 1,
      "num_upd_ops" : 0,
      "tablename" : "pg_user_mapping"
   },
   "select * from gp_distribution_policy where localoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbcat.c" : 3
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (localoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_47(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = GpPolicyRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(GpPolicyRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_gp_policy_localoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   GpPolicyLocalOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "GpPolicyLocalOidIndexId",
      "func_name" : "caql_basic_fn_47",
      "func_note" : "",
      "func_number" : "47",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_1",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "gp_distribution_policy"
   },
   "select * from gp_fastsequence where objid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/gp_fastsequence.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (objid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_48(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = FastSequenceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FastSequenceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_gp_fastsequence_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   FastSequenceObjidObjmodContentidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "FastSequenceObjidObjmodContentidIndexId",
      "func_name" : "caql_basic_fn_48",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex gp_fastsequence(objid, ...) <FastSequenceObjidObjmodContentidIndexId>\n",
      "func_number" : "48",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_48(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tFastSequenceObjidObjmodContentidIndexId: objid, objmod, contentid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_gp_fastsequence_objid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_gp_fastsequence_objmod,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT8OID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_gp_fastsequence_contentid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, FastSequenceRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"gp_fastsequence\",\n\t\t\t\t\t  \"objid, objmod, contentid\",\n\t\t\t\t\t  FastSequenceObjidObjmodContentidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_gp_fastsequence_objid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_gp_fastsequence_objmod,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT8OID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_gp_fastsequence_contentid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, FastSequenceRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"gp_fastsequence\",\n\t\t\t\t\t  \"objid, objmod, contentid\",\n\t\t\t\t\t  FastSequenceObjidObjmodContentidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_class (oid) <- (objid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_gp_fastsequence_objid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_gp_fastsequence_objid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, RelationRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_class\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ClassOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_48 */\n",
      "iud_func_name" : "caql_iud_fn_48",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "gp_fastsequence"
   },
   "select * from gp_fastsequence where objid = :1 and objmod = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/gp_fastsequence.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (objid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_49(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = FastSequenceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FastSequenceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_gp_fastsequence_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_gp_fastsequence_objmod,\n\t\t\t\tBTEqualStrategyNumber, F_INT8EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   FastSequenceObjidObjmodContentidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "FastSequenceObjidObjmodContentidIndexId",
      "func_name" : "caql_basic_fn_49",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex gp_fastsequence(objid, ...) <FastSequenceObjidObjmodContentidIndexId>\n",
      "func_number" : "49",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_48",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "gp_fastsequence"
   },
   "select * from gp_fastsequence where objid = :1 and objmod = :2 and contentid = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/gp_fastsequence.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (objid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_50(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = FastSequenceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FastSequenceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_gp_fastsequence_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_gp_fastsequence_objmod,\n\t\t\t\tBTEqualStrategyNumber, F_INT8EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_gp_fastsequence_contentid,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   FastSequenceObjidObjmodContentidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "FastSequenceObjidObjmodContentidIndexId",
      "func_name" : "caql_basic_fn_50",
      "func_note" : "",
      "func_number" : "50",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_48",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "gp_fastsequence"
   },
   "select * from gp_segment_configuration where registration_order = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbutil.c" : 1,
         "../../../..//src/backend/utils/gp/segadmin.c" : 2
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_51(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = GpSegmentConfigRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(GpSegmentConfigRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_gp_segment_configuration_registration_order,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   GpSegmentConfigRegistration_orderIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "GpSegmentConfigRegistration_orderIndexId",
      "func_name" : "caql_basic_fn_51",
      "func_note" : "",
      "func_number" : "51",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_2",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "gp_segment_configuration"
   },
   "select * from gp_segment_configuration where role = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbutil.c" : 1,
         "../../../..//src/backend/utils/gp/segadmin.c" : 3
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_52(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = GpSegmentConfigRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(GpSegmentConfigRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_gp_segment_configuration_role,\n\t\t\t\tBTEqualStrategyNumber, F_CHAREQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   GpSegmentConfigRoleIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "GpSegmentConfigRoleIndexId",
      "func_name" : "caql_basic_fn_52",
      "func_note" : "",
      "func_number" : "52",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_2",
      "num_del_ops" : 2,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "gp_segment_configuration"
   },
   "select * from pg_aggregate where aggfnoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbgroup.c" : 1,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 1,
         "../../../..//src/backend/executor/nodeAgg.c" : 1,
         "../../../..//src/backend/executor/nodeWindow.c" : 1,
         "../../../..//src/backend/optimizer/plan/planwindow.c" : 1,
         "../../../..//src/backend/optimizer/util/clauses.c" : 1,
         "../../../..//src/backend/parser/parse_func.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 5
      },
      "foreign_key_tables" : {
         "pg_operator" : {
            "(oid) <- (aggsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (aggfinalfn)" : 1,
            "(oid) <- (aggfnoid)" : 1,
            "(oid) <- (agginvprelimfn)" : 1,
            "(oid) <- (agginvtransfn)" : 1,
            "(oid) <- (aggprelimfn)" : 1,
            "(oid) <- (aggtransfn)" : 1
         },
         "pg_type" : {
            "(oid) <- (aggtranstype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_53(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AGGFNOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AggregateRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AggregateRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_aggregate_aggfnoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AggregateAggfnoidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AggregateAggfnoidIndexId",
      "func_name" : "caql_basic_fn_53",
      "func_note" : "",
      "func_number" : "53",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_3",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AGGFNOID",
      "tablename" : "pg_aggregate"
   },
   "select * from pg_am where amname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/indexcmds.c" : 2,
         "../../../..//src/backend/commands/opclasscmds.c" : 4
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (ambeginscan)" : 1,
            "(oid) <- (ambuild)" : 1,
            "(oid) <- (ambulkdelete)" : 1,
            "(oid) <- (amcostestimate)" : 1,
            "(oid) <- (amendscan)" : 1,
            "(oid) <- (amgetmulti)" : 1,
            "(oid) <- (amgettuple)" : 1,
            "(oid) <- (aminsert)" : 1,
            "(oid) <- (ammarkpos)" : 1,
            "(oid) <- (amoptions)" : 1,
            "(oid) <- (amrescan)" : 1,
            "(oid) <- (amrestrpos)" : 1,
            "(oid) <- (amvacuumcleanup)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_54(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AMNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_am_amname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AmNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AmNameIndexId",
      "func_name" : "caql_basic_fn_54",
      "func_note" : "",
      "func_number" : "54",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_54(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tAmNameIndexId: amname\n\tAmOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_am\",\n\t\t\t\t\t  \"amname\",\n\t\t\t\t\t  AmNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_am\",\n\t\t\t\t\t  \"amname\",\n\t\t\t\t\t  AmNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_am\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  AmOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, AccessMethodRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_am\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  AmOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_am primary key may be referenced in:\n\t\t  pg_class (relam) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_proc (oid) <- (ambeginscan)\n\t\t  pg_proc (oid) <- (ambuild)\n\t\t  pg_proc (oid) <- (ambulkdelete)\n\t\t  pg_proc (oid) <- (amcostestimate)\n\t\t  pg_proc (oid) <- (amendscan)\n\t\t  pg_proc (oid) <- (amgetmulti)\n\t\t  pg_proc (oid) <- (amgettuple)\n\t\t  pg_proc (oid) <- (aminsert)\n\t\t  pg_proc (oid) <- (ammarkpos)\n\t\t  pg_proc (oid) <- (amoptions)\n\t\t  pg_proc (oid) <- (amrescan)\n\t\t  pg_proc (oid) <- (amrestrpos)\n\t\t  pg_proc (oid) <- (amvacuumcleanup) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_ambeginscan,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_ambeginscan,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_ambuild,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_ambuild,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_ambulkdelete,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_ambulkdelete,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amcostestimate,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amcostestimate,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amendscan,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amendscan,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amgetmulti,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amgetmulti,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amgettuple,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amgettuple,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_aminsert,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_aminsert,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_ammarkpos,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_ammarkpos,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amoptions,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amoptions,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amrescan,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amrescan,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amrestrpos,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amrestrpos,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_am_amvacuumcleanup,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_am_amvacuumcleanup,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_54 */\n",
      "iud_func_name" : "caql_iud_fn_54",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AMNAME",
      "tablename" : "pg_am"
   },
   "select * from pg_am where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (ambeginscan)" : 1,
            "(oid) <- (ambuild)" : 1,
            "(oid) <- (ambulkdelete)" : 1,
            "(oid) <- (amcostestimate)" : 1,
            "(oid) <- (amendscan)" : 1,
            "(oid) <- (amgetmulti)" : 1,
            "(oid) <- (amgettuple)" : 1,
            "(oid) <- (aminsert)" : 1,
            "(oid) <- (ammarkpos)" : 1,
            "(oid) <- (amoptions)" : 1,
            "(oid) <- (amrescan)" : 1,
            "(oid) <- (amrestrpos)" : 1,
            "(oid) <- (amvacuumcleanup)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_55(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AMOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AmOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AmOidIndexId",
      "func_name" : "caql_basic_fn_55",
      "func_note" : "",
      "func_number" : "55",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_54",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AMOID",
      "tablename" : "pg_am"
   },
   "select * from pg_amop where amopclaid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/opclasscmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_56(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amop_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodStrategyIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodStrategyIndexId",
      "func_name" : "caql_basic_fn_56",
      "func_note" : "index pg_opclass(oid) <OpclassOidIndexId> is a prefix of \n\tindex pg_amop(amopclaid, ...) <AccessMethodStrategyIndexId>\n",
      "func_number" : "56",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_amop"
   },
   "select * from pg_amop where amopclaid = :1 and amopsubtype = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_57(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amop_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_amop_amopsubtype,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodStrategyIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodStrategyIndexId",
      "func_name" : "caql_basic_fn_57",
      "func_note" : "index pg_opclass(oid) <OpclassOidIndexId> is a prefix of \n\tindex pg_amop(amopclaid, ...) <AccessMethodStrategyIndexId>\n",
      "func_number" : "57",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_amop"
   },
   "select * from pg_amop where amopclaid = :1 and amopsubtype = :2 and amopstrategy = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_58(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AMOPSTRATEGY;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amop_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_amop_amopsubtype,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_amop_amopstrategy,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodStrategyIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodStrategyIndexId",
      "func_name" : "caql_basic_fn_58",
      "func_note" : "",
      "func_number" : "58",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AMOPSTRATEGY",
      "tablename" : "pg_amop"
   },
   "select * from pg_amop where amopopr = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_59(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amop_amopopr,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodOperatorIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodOperatorIndexId",
      "func_name" : "caql_basic_fn_59",
      "func_note" : "index pg_operator(oid) <OperatorOidIndexId> is a prefix of \n\tindex pg_amop(amopopr, ...) <AccessMethodOperatorIndexId>\n",
      "func_number" : "59",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_amop"
   },
   "select * from pg_amop where amopopr = :1 ORDER_BY AccessMethodOperatorIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/executor/nodeMergejoin.c" : 1,
         "../../../..//src/backend/optimizer/util/predtest.c" : 2,
         "../../../..//src/backend/parser/parse_clause.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 3,
         "../../../..//src/backend/utils/sort/tuplesort.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_60(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AMOPOPID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amop_amopopr,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodOperatorIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodOperatorIndexId",
      "func_name" : "caql_basic_fn_60",
      "func_note" : "index pg_operator(oid) <OperatorOidIndexId> is a prefix of \n\tindex pg_amop(amopopr, ...) <AccessMethodOperatorIndexId>\nPredicate does not match all index columns ( 1 != 2 ),\ncan only use syscache for SearchSysCacheList case\n",
      "func_number" : "60",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AMOPOPID",
      "tablename" : "pg_amop"
   },
   "select * from pg_amop where amopopr = :1 and amopclaid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/optimizer/util/predtest.c" : 2,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 3
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (amopopr)" : 1
         },
         "pg_type" : {
            "(oid) <- (amopsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_61(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AMOPOPID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodOperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodOperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amop_amopopr,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_amop_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodOperatorIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodOperatorIndexId",
      "func_name" : "caql_basic_fn_61",
      "func_note" : "",
      "func_number" : "61",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_4",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AMOPOPID",
      "tablename" : "pg_amop"
   },
   "select * from pg_amproc where amopclaid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/opclasscmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (amproc)" : 1
         },
         "pg_type" : {
            "(oid) <- (amprocsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_62(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amproc_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodProcedureIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodProcedureIndexId",
      "func_name" : "caql_basic_fn_62",
      "func_note" : "index pg_opclass(oid) <OpclassOidIndexId> is a prefix of \n\tindex pg_amproc(amopclaid, ...) <AccessMethodProcedureIndexId>\n",
      "func_number" : "62",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_5",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_amproc"
   },
   "select * from pg_amproc where amopclaid = :1 and amprocsubtype = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (amproc)" : 1
         },
         "pg_type" : {
            "(oid) <- (amprocsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_63(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amproc_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_amproc_amprocsubtype,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodProcedureIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodProcedureIndexId",
      "func_name" : "caql_basic_fn_63",
      "func_note" : "index pg_opclass(oid) <OpclassOidIndexId> is a prefix of \n\tindex pg_amproc(amopclaid, ...) <AccessMethodProcedureIndexId>\n",
      "func_number" : "63",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_5",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_amproc"
   },
   "select * from pg_amproc where amopclaid = :1 and amprocsubtype = :2 and amprocnum = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_opclass" : {
            "(oid) <- (amopclaid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (amproc)" : 1
         },
         "pg_type" : {
            "(oid) <- (amprocsubtype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_64(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AMPROCNUM;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AccessMethodProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AccessMethodProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_amproc_amopclaid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_amproc_amprocsubtype,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_amproc_amprocnum,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AccessMethodProcedureIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AccessMethodProcedureIndexId",
      "func_name" : "caql_basic_fn_64",
      "func_note" : "",
      "func_number" : "64",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_5",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AMPROCNUM",
      "tablename" : "pg_amproc"
   },
   "select * from pg_appendonly where relid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_appendonly.c" : 5
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (relid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_65(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AppendOnlyRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AppendOnlyRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_appendonly_relid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AppendOnlyRelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AppendOnlyRelidIndexId",
      "func_name" : "caql_basic_fn_65",
      "func_note" : "",
      "func_number" : "65",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_6",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "tablename" : "pg_appendonly"
   },
   "select * from pg_attrdef where adrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (adrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_66(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttrDefaultRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttrDefaultRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attrdef_adrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttrDefaultIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttrDefaultIndexId",
      "func_name" : "caql_basic_fn_66",
      "func_note" : "",
      "func_number" : "66",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_7",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_attrdef"
   },
   "select * from pg_attrdef where adrelid = :1 and adnum = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (adrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_67(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttrDefaultRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttrDefaultRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attrdef_adrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_attrdef_adnum,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttrDefaultIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttrDefaultIndexId",
      "func_name" : "caql_basic_fn_67",
      "func_note" : "",
      "func_number" : "67",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_7",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_attrdef"
   },
   "select * from pg_attrdef where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (adrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_68(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttrDefaultRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttrDefaultRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttrDefaultOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttrDefaultOidIndexId",
      "func_name" : "caql_basic_fn_68",
      "func_note" : "",
      "func_number" : "68",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_7",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_attrdef"
   },
   "select * from pg_attribute where attrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (attrelid)" : 1
         },
         "pg_type" : {
            "(oid) <- (atttypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_69(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttributeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttributeRelidNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttributeRelidNameIndexId",
      "func_name" : "caql_basic_fn_69",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_attribute(attrelid, ...) <AttributeRelidNameIndexId>\n",
      "func_number" : "69",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_8",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_attribute"
   },
   "select * from pg_attribute where attrelid = :1 and attname = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (attrelid)" : 1
         },
         "pg_type" : {
            "(oid) <- (atttypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_70(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = ATTNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttributeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_attribute_attname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttributeRelidNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttributeRelidNameIndexId",
      "func_name" : "caql_basic_fn_70",
      "func_note" : "",
      "func_number" : "70",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_8",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "ATTNAME",
      "tablename" : "pg_attribute"
   },
   "select * from pg_attribute where attrelid = :1 and attnum = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 3,
         "../../../..//src/backend/cdb/cdbsubselect.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 1,
         "../../../..//src/backend/parser/parse_relation.c" : 3,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 4
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (attrelid)" : 1
         },
         "pg_type" : {
            "(oid) <- (atttypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_71(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = ATTNUM;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttributeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_attribute_attnum,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttributeRelidNumIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttributeRelidNumIndexId",
      "func_name" : "caql_basic_fn_71",
      "func_note" : "",
      "func_number" : "71",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_8",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 4,
      "syscacheid" : "ATTNUM",
      "tablename" : "pg_attribute"
   },
   "select * from pg_attribute where attrelid = :1 and attnum > :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (attrelid)" : 1
         },
         "pg_type" : {
            "(oid) <- (atttypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_72(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttributeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_attribute_attnum,\n\t\t\t\tBTGreaterStrategyNumber, F_INT2GT,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttributeRelidNumIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttributeRelidNumIndexId",
      "func_name" : "caql_basic_fn_72",
      "func_note" : "WHERE clause is not strict equality\nCould not use syscache due to inequality\n",
      "func_number" : "72",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_8",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_attribute"
   },
   "select * from pg_attribute_encoding where attrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_attribute_encoding.c" : 2
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (attrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_73(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AttributeEncodingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AttributeEncodingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_attribute_encoding_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AttributeEncodingAttrelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AttributeEncodingAttrelidIndexId",
      "func_name" : "caql_basic_fn_73",
      "func_note" : "",
      "func_number" : "73",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_9",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_attribute_encoding"
   },
   "select * from pg_auth_members where member = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (member)" : 1,
            "(oid) <- (roleid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_74(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AuthMemRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthMemRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_auth_members_member,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AuthMemMemRoleIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AuthMemMemRoleIndexId",
      "func_name" : "caql_basic_fn_74",
      "func_note" : "index pg_authid(oid) <AuthIdOidIndexId> is a prefix of \n\tindex pg_auth_members(member, ...) <AuthMemMemRoleIndexId>\n",
      "func_number" : "74",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_10",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_auth_members"
   },
   "select * from pg_auth_members where member = :1 ORDER_BY AuthMemMemRoleIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/adt/acl.c" : 3
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (member)" : 1,
            "(oid) <- (roleid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_75(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AUTHMEMMEMROLE;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AuthMemRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthMemRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_auth_members_member,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AuthMemMemRoleIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AuthMemMemRoleIndexId",
      "func_name" : "caql_basic_fn_75",
      "func_note" : "index pg_authid(oid) <AuthIdOidIndexId> is a prefix of \n\tindex pg_auth_members(member, ...) <AuthMemMemRoleIndexId>\nPredicate does not match all index columns ( 1 != 2 ),\ncan only use syscache for SearchSysCacheList case\n",
      "func_number" : "75",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_10",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "AUTHMEMMEMROLE",
      "tablename" : "pg_auth_members"
   },
   "select * from pg_auth_members where roleid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (member)" : 1,
            "(oid) <- (roleid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_76(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AuthMemRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthMemRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_auth_members_roleid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AuthMemRoleMemIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AuthMemRoleMemIndexId",
      "func_name" : "caql_basic_fn_76",
      "func_note" : "index pg_authid(oid) <AuthIdOidIndexId> is a prefix of \n\tindex pg_auth_members(roleid, ...) <AuthMemRoleMemIndexId>\n",
      "func_number" : "76",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_10",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_auth_members"
   },
   "select * from pg_auth_members where roleid = :1 and member = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (member)" : 1,
            "(oid) <- (roleid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_77(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AUTHMEMROLEMEM;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AuthMemRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthMemRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_auth_members_roleid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_auth_members_member,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AuthMemRoleMemIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AuthMemRoleMemIndexId",
      "func_name" : "caql_basic_fn_77",
      "func_note" : "",
      "func_number" : "77",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_10",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "AUTHMEMROLEMEM",
      "tablename" : "pg_auth_members"
   },
   "select * from pg_auth_time_constraint where authid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (authid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_78(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = AuthTimeConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthTimeConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_auth_time_constraint_authid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_78",
      "func_note" : "",
      "func_number" : "78",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_11",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_auth_time_constraint"
   },
   "select * from pg_authid where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/catalog/pg_shdepend.c" : 1,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/dbcommands.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 1,
         "../../../..//src/backend/commands/user.c" : 1,
         "../../../..//src/backend/utils/adt/acl.c" : 3,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1,
         "../../../..//src/backend/utils/init/miscinit.c" : 1,
         "../../../..//src/backend/utils/misc/superuser.c" : 1,
         "../../../..//src/backend/utils/resscheduler/resscheduler.c" : 1
      },
      "foreign_key_tables" : {
         "pg_resqueue" : {
            "(oid) <- (rolresqueue)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_79(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AUTHOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AuthIdRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthIdRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AuthIdOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AuthIdOidIndexId",
      "func_name" : "caql_basic_fn_79",
      "func_note" : "",
      "func_number" : "79",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_12",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "AUTHOID",
      "tablename" : "pg_authid"
   },
   "select * from pg_authid where rolname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/user.c" : 6,
         "../../../..//src/backend/commands/variable.c" : 2,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1,
         "../../../..//src/backend/utils/init/miscinit.c" : 1
      },
      "foreign_key_tables" : {
         "pg_resqueue" : {
            "(oid) <- (rolresqueue)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_80(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = AUTHNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = AuthIdRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(AuthIdRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_authid_rolname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   AuthIdRolnameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "AuthIdRolnameIndexId",
      "func_name" : "caql_basic_fn_80",
      "func_note" : "",
      "func_number" : "80",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_12",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 4,
      "syscacheid" : "AUTHNAME",
      "tablename" : "pg_authid"
   },
   "select * from pg_cast where castsource = :1 and casttarget = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 2,
         "../../../..//src/backend/parser/parse_coerce.c" : 3
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (castfunc)" : 1
         },
         "pg_type" : {
            "(oid) <- (castsource)" : 1,
            "(oid) <- (casttarget)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_81(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = CASTSOURCETARGET;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = CastRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(CastRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_cast_castsource,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_cast_casttarget,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   CastSourceTargetIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "CastSourceTargetIndexId",
      "func_name" : "caql_basic_fn_81",
      "func_note" : "",
      "func_number" : "81",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_13",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "CASTSOURCETARGET",
      "tablename" : "pg_cast"
   },
   "select * from pg_cast where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (castfunc)" : 1
         },
         "pg_type" : {
            "(oid) <- (castsource)" : 1,
            "(oid) <- (casttarget)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_82(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = CastRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(CastRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   CastOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "CastOidIndexId",
      "func_name" : "caql_basic_fn_82",
      "func_note" : "",
      "func_number" : "82",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_13",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_cast"
   },
   "select * from pg_class" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/indexcmds.c" : 1,
         "../../../..//src/backend/commands/vacuum.c" : 1
      },
      "foreign_key_tables" : {
         "pg_am" : {
            "(oid) <- (relam)" : 1
         },
         "pg_authid" : {
            "(oid) <- (relowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (reltoastidxid)" : 1,
            "(oid) <- (reltoastrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (relnamespace)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (reltablespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (reltype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_83(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = RelationRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RelationRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\t\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_83",
      "func_note" : "",
      "func_number" : "83",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_14",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_class"
   },
   "select * from pg_class where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/access/heap/heapam.c" : 1,
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/catalog/dependency.c" : 2,
         "../../../..//src/backend/catalog/heap.c" : 3,
         "../../../..//src/backend/catalog/index.c" : 2,
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/catalog/pg_constraint.c" : 1,
         "../../../..//src/backend/catalog/toasting.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 3,
         "../../../..//src/backend/commands/analyze.c" : 1,
         "../../../..//src/backend/commands/cluster.c" : 4,
         "../../../..//src/backend/commands/indexcmds.c" : 3,
         "../../../..//src/backend/commands/sequence.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 13,
         "../../../..//src/backend/commands/trigger.c" : 2,
         "../../../..//src/backend/commands/vacuum.c" : 1,
         "../../../..//src/backend/optimizer/plan/planpartition.c" : 1,
         "../../../..//src/backend/parser/parse_relation.c" : 1,
         "../../../..//src/backend/parser/parse_utilcmd.c" : 1,
         "../../../..//src/backend/rewrite/rewriteSupport.c" : 1,
         "../../../..//src/backend/tcop/utility.c" : 3,
         "../../../..//src/backend/utils/adt/acl.c" : 3,
         "../../../..//src/backend/utils/adt/regproc.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 5,
         "../../../..//src/backend/utils/adt/selfuncs.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 9,
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_am" : {
            "(oid) <- (relam)" : 1
         },
         "pg_authid" : {
            "(oid) <- (relowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (reltoastidxid)" : 1,
            "(oid) <- (reltoastrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (relnamespace)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (reltablespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (reltype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_84(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = RELOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = RelationRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RelationRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ClassOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ClassOidIndexId",
      "func_name" : "caql_basic_fn_84",
      "func_note" : "",
      "func_number" : "84",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_14",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 27,
      "syscacheid" : "RELOID",
      "tablename" : "pg_class"
   },
   "select * from pg_class where relkind = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/analyze.c" : 1,
         "../../../..//src/backend/commands/vacuum.c" : 1
      },
      "foreign_key_tables" : {
         "pg_am" : {
            "(oid) <- (relam)" : 1
         },
         "pg_authid" : {
            "(oid) <- (relowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (reltoastidxid)" : 1,
            "(oid) <- (reltoastrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (relnamespace)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (reltablespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (reltype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_85(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = RelationRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RelationRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_class_relkind,\n\t\t\t\tBTEqualStrategyNumber, F_CHAREQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_85",
      "func_note" : "",
      "func_number" : "85",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_14",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_class"
   },
   "select * from pg_class where relname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/adt/regproc.c" : 1
      },
      "foreign_key_tables" : {
         "pg_am" : {
            "(oid) <- (relam)" : 1
         },
         "pg_authid" : {
            "(oid) <- (relowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (reltoastidxid)" : 1,
            "(oid) <- (reltoastrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (relnamespace)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (reltablespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (reltype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_86(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = RelationRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RelationRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_class_relname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ClassNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ClassNameNspIndexId",
      "func_name" : "caql_basic_fn_86",
      "func_note" : "",
      "func_number" : "86",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_14",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_class"
   },
   "select * from pg_class where relname = :1 and relnamespace = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_am" : {
            "(oid) <- (relam)" : 1
         },
         "pg_authid" : {
            "(oid) <- (relowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (reltoastidxid)" : 1,
            "(oid) <- (reltoastrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (relnamespace)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (reltablespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (reltype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_87(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = RELNAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = RelationRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RelationRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_class_relname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_class_relnamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ClassNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ClassNameNspIndexId",
      "func_name" : "caql_basic_fn_87",
      "func_note" : "",
      "func_number" : "87",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_14",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "RELNAMENSP",
      "tablename" : "pg_class"
   },
   "select * from pg_compression where compname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_compression.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (compowner)" : 1
         },
         "pg_proc" : {
            "(oid) <- (compcompressor)" : 1,
            "(oid) <- (compconstructor)" : 1,
            "(oid) <- (compdecompressor)" : 1,
            "(oid) <- (compdestructor)" : 1,
            "(oid) <- (compvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_88(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = CompressionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(CompressionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_compression_compname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   CompressionCompnameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "CompressionCompnameIndexId",
      "func_name" : "caql_basic_fn_88",
      "func_note" : "",
      "func_number" : "88",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_88(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tCompressionOidIndexId: oid\n\tCompressionCompnameIndexId: compname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, CompressionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_compression\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  CompressionOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, CompressionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_compression\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  CompressionOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, CompressionRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_compression\",\n\t\t\t\t\t  \"compname\",\n\t\t\t\t\t  CompressionCompnameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, CompressionRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_compression\",\n\t\t\t\t\t  \"compname\",\n\t\t\t\t\t  CompressionCompnameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_authid (oid) <- (compowner)\n\t\t  pg_proc (oid) <- (compcompressor)\n\t\t  pg_proc (oid) <- (compconstructor)\n\t\t  pg_proc (oid) <- (compdecompressor)\n\t\t  pg_proc (oid) <- (compdestructor)\n\t\t  pg_proc (oid) <- (compvalidator) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compowner,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compowner,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, AuthIdRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_authid\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  AuthIdOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compcompressor,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compcompressor,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compconstructor,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compconstructor,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compdecompressor,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compdecompressor,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compdestructor,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compdestructor,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_compression_compvalidator,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_compression_compvalidator,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_88 */\n",
      "iud_func_name" : "caql_iud_fn_88",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_compression"
   },
   "select * from pg_constraint where conname = :1 and connamespace = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_constraint.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (confrelid)" : 1,
            "(oid) <- (conrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (contypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_89(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_constraint_conname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_constraint_connamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConstraintNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConstraintNameNspIndexId",
      "func_name" : "caql_basic_fn_89",
      "func_note" : "",
      "func_number" : "89",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_15",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_constraint"
   },
   "select * from pg_constraint where conrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/catalog/pg_constraint.c" : 2,
         "../../../..//src/backend/cdb/cdbpartindex.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 2,
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 2,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1,
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (confrelid)" : 1,
            "(oid) <- (conrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (contypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_90(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConstraintRelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConstraintRelidIndexId",
      "func_name" : "caql_basic_fn_90",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_constraint(conrelid, ...) <ConstraintRelidIndexId>\n",
      "func_number" : "90",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_15",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_constraint"
   },
   "select * from pg_constraint where contypid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_constraint.c" : 1,
         "../../../..//src/backend/commands/typecmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (confrelid)" : 1,
            "(oid) <- (conrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (contypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_91(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_constraint_contypid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConstraintTypidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConstraintTypidIndexId",
      "func_name" : "caql_basic_fn_91",
      "func_note" : "index pg_type(oid) <TypeOidIndexId> is a prefix of \n\tindex pg_constraint(contypid, ...) <ConstraintTypidIndexId>\n",
      "func_number" : "91",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_15",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_constraint"
   },
   "select * from pg_constraint where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/pg_constraint.c" : 2,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 4
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (confrelid)" : 1,
            "(oid) <- (conrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (contypid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_92(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConstraintRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConstraintRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConstraintOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConstraintOidIndexId",
      "func_name" : "caql_basic_fn_92",
      "func_note" : "",
      "func_number" : "92",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_15",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_constraint"
   },
   "select * from pg_conversion where conname = :1 and connamespace = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1,
         "../../../..//src/backend/catalog/pg_conversion.c" : 2,
         "../../../..//src/backend/commands/conversioncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (conowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (conproc)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_93(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = CONNAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConversionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConversionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_conversion_conname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_conversion_connamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConversionNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConversionNameNspIndexId",
      "func_name" : "caql_basic_fn_93",
      "func_note" : "",
      "func_number" : "93",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_16",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "CONNAMENSP",
      "tablename" : "pg_conversion"
   },
   "select * from pg_conversion where connamespace = :1 and conforencoding = :2 and contoencoding = :3 ORDER_BY ConversionDefaultIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_conversion.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (conowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (conproc)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_94(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = CONDEFAULT;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConversionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConversionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_conversion_connamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_conversion_conforencoding,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_conversion_contoencoding,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConversionDefaultIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConversionDefaultIndexId",
      "func_name" : "caql_basic_fn_94",
      "func_note" : "index pg_namespace(oid) <NamespaceOidIndexId> is a prefix of \n\tindex pg_conversion(connamespace, ...) <ConversionDefaultIndexId>\nPredicate does not match all index columns ( 3 != 4 ),\ncan only use syscache for SearchSysCacheList case\n",
      "func_number" : "94",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_16",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "CONDEFAULT",
      "tablename" : "pg_conversion"
   },
   "select * from pg_conversion where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/catalog/pg_conversion.c" : 3,
         "../../../..//src/backend/commands/conversioncmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (conowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (connamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (conproc)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_95(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = CONOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ConversionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ConversionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ConversionOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ConversionOidIndexId",
      "func_name" : "caql_basic_fn_95",
      "func_note" : "",
      "func_number" : "95",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_16",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "CONOID",
      "tablename" : "pg_conversion"
   },
   "select * from pg_database" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/vacuum.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (datdba)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (dattablespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_96(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = DatabaseRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DatabaseRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\t\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_96",
      "func_note" : "",
      "func_number" : "96",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_17",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_database"
   },
   "select * from pg_database where datname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/dbcommands.c" : 5
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (datdba)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (dattablespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_97(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DatabaseRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DatabaseRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_database_datname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DatabaseNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DatabaseNameIndexId",
      "func_name" : "caql_basic_fn_97",
      "func_note" : "",
      "func_number" : "97",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_17",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "tablename" : "pg_database"
   },
   "select * from pg_database where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/commands/dbcommands.c" : 4,
         "../../../..//src/backend/commands/vacuum.c" : 1,
         "../../../..//src/backend/utils/adt/acl.c" : 3
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (datdba)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (dattablespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_98(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = DATABASEOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DatabaseRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DatabaseRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DatabaseOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DatabaseOidIndexId",
      "func_name" : "caql_basic_fn_98",
      "func_note" : "",
      "func_number" : "98",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_17",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "syscacheid" : "DATABASEOID",
      "tablename" : "pg_database"
   },
   "select * from pg_depend where classid = :1 and objid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/pg_depend.c" : 4,
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_99(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_depend_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_depend_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DependDependerIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DependDependerIndexId",
      "func_name" : "caql_basic_fn_99",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_depend(classid, ...) <DependDependerIndexId>\n",
      "func_number" : "99",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_18",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "tablename" : "pg_depend"
   },
   "select * from pg_depend where classid = :1 and objid = :2 and objsubid = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/pg_depend.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_100(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_depend_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_depend_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_depend_objsubid,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DependDependerIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DependDependerIndexId",
      "func_name" : "caql_basic_fn_100",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_depend(classid, ...) <DependDependerIndexId>\n",
      "func_number" : "100",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_18",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "tablename" : "pg_depend"
   },
   "select * from pg_depend where refclassid = :1 and refobjid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 2,
         "../../../..//src/backend/catalog/pg_depend.c" : 1,
         "../../../..//src/backend/catalog/pg_proc.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 3,
         "../../../..//src/backend/commands/typecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_101(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_depend_refclassid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_depend_refobjid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DependReferenceIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DependReferenceIndexId",
      "func_name" : "caql_basic_fn_101",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_depend(refclassid, ...) <DependReferenceIndexId>\n",
      "func_number" : "101",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_18",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_depend"
   },
   "select * from pg_depend where refclassid = :1 and refobjid = :2 and refobjsubid = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 2,
         "../../../..//src/backend/catalog/pg_depend.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_102(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_depend_refclassid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_depend_refobjid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_depend_refobjsubid,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DependReferenceIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DependReferenceIndexId",
      "func_name" : "caql_basic_fn_102",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_depend(refclassid, ...) <DependReferenceIndexId>\n",
      "func_number" : "102",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_18",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_depend"
   },
   "select * from pg_description where objoid = :1 and classoid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_103(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DescriptionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DescriptionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_description_objoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_description_classoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DescriptionObjIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DescriptionObjIndexId",
      "func_name" : "caql_basic_fn_103",
      "func_note" : "",
      "func_number" : "103",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_19",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_description"
   },
   "select * from pg_description where objoid = :1 and classoid = :2 and objsubid = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_104(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = DescriptionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(DescriptionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_description_objoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_description_classoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_description_objsubid,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   DescriptionObjIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "DescriptionObjIndexId",
      "func_name" : "caql_basic_fn_104",
      "func_note" : "",
      "func_number" : "104",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_19",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_description"
   },
   "select * from pg_extprotocol where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/catalog/pg_extprotocol.c" : 2
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (ptcreadfn)" : 1,
            "(oid) <- (ptcvalidatorfn)" : 1,
            "(oid) <- (ptcwritefn)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_105(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ExtprotocolRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ExtprotocolRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ExtprotocolOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ExtprotocolOidIndexId",
      "func_name" : "caql_basic_fn_105",
      "func_note" : "",
      "func_number" : "105",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_20",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_extprotocol"
   },
   "select * from pg_extprotocol where ptcname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_extprotocol.c" : 5,
         "../../../..//src/backend/commands/extprotocolcmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (ptcreadfn)" : 1,
            "(oid) <- (ptcvalidatorfn)" : 1,
            "(oid) <- (ptcwritefn)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_106(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ExtprotocolRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ExtprotocolRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_extprotocol_ptcname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ExtprotocolPtcnameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ExtprotocolPtcnameIndexId",
      "func_name" : "caql_basic_fn_106",
      "func_note" : "",
      "func_number" : "106",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_20",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_extprotocol"
   },
   "select * from pg_exttable where reloid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_exttable.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (fmterrtbl)" : 1,
            "(oid) <- (reloid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_107(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ExtTableRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ExtTableRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_exttable_reloid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ExtTableReloidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ExtTableReloidIndexId",
      "func_name" : "caql_basic_fn_107",
      "func_note" : "",
      "func_number" : "107",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_21",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_exttable"
   },
   "select * from pg_filespace where fsname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/filespace.c" : 4
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_108(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = FileSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FileSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_filespace_fsname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   FilespaceNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "FilespaceNameIndexId",
      "func_name" : "caql_basic_fn_108",
      "func_note" : "",
      "func_number" : "108",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_22",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_filespace"
   },
   "select * from pg_filespace where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/commands/filespace.c" : 2
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_109(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = FileSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FileSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   FilespaceOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "FilespaceOidIndexId",
      "func_name" : "caql_basic_fn_109",
      "func_note" : "",
      "func_number" : "109",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_22",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_filespace"
   },
   "select * from pg_filespace_entry where fsedbid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/filespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_filespace" : {
            "(oid) <- (fsefsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_110(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = FileSpaceEntryRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FileSpaceEntryRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_filespace_entry_fsedbid,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_110",
      "func_note" : "",
      "func_number" : "110",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_23",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_filespace_entry"
   },
   "select * from pg_filespace_entry where fsefsoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/filespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_filespace" : {
            "(oid) <- (fsefsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_111(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = FileSpaceEntryRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(FileSpaceEntryRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_filespace_entry_fsefsoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   FileSpaceEntryFsefsoidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "FileSpaceEntryFsefsoidIndexId",
      "func_name" : "caql_basic_fn_111",
      "func_note" : "index pg_filespace(oid) <FilespaceOidIndexId> is a prefix of \n\tindex pg_filespace_entry(fsefsoid, ...) <FileSpaceEntryFsefsoidIndexId>\n",
      "func_number" : "111",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_23",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_filespace_entry"
   },
   "select * from pg_foreign_data_wrapper where fdwname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (fdwowner)" : 1
         },
         "pg_proc" : {
            "(oid) <- (fdwvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_112(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = FOREIGNDATAWRAPPERNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ForeignDataWrapperRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignDataWrapperRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_foreign_data_wrapper_fdwname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ForeignDataWrapperNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ForeignDataWrapperNameIndexId",
      "func_name" : "caql_basic_fn_112",
      "func_note" : "",
      "func_number" : "112",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_24",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "FOREIGNDATAWRAPPERNAME",
      "tablename" : "pg_foreign_data_wrapper"
   },
   "select * from pg_foreign_data_wrapper where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 2,
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (fdwowner)" : 1
         },
         "pg_proc" : {
            "(oid) <- (fdwvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_113(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = FOREIGNDATAWRAPPEROID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ForeignDataWrapperRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignDataWrapperRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ForeignDataWrapperOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ForeignDataWrapperOidIndexId",
      "func_name" : "caql_basic_fn_113",
      "func_note" : "",
      "func_number" : "113",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_24",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "FOREIGNDATAWRAPPEROID",
      "tablename" : "pg_foreign_data_wrapper"
   },
   "select * from pg_foreign_server where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (srvowner)" : 1
         },
         "pg_foreign_data_wrapper" : {
            "(oid) <- (srvfdw)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_114(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = FOREIGNSERVEROID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ForeignServerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignServerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ForeignServerOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ForeignServerOidIndexId",
      "func_name" : "caql_basic_fn_114",
      "func_note" : "",
      "func_number" : "114",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_25",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "FOREIGNSERVEROID",
      "tablename" : "pg_foreign_server"
   },
   "select * from pg_foreign_server where srvname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (srvowner)" : 1
         },
         "pg_foreign_data_wrapper" : {
            "(oid) <- (srvfdw)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_115(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = FOREIGNSERVERNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ForeignServerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignServerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_foreign_server_srvname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ForeignServerNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ForeignServerNameIndexId",
      "func_name" : "caql_basic_fn_115",
      "func_note" : "",
      "func_number" : "115",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_25",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "FOREIGNSERVERNAME",
      "tablename" : "pg_foreign_server"
   },
   "select * from pg_foreign_table where reloid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (reloid)" : 1
         },
         "pg_foreign_server" : {
            "(oid) <- (server)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_116(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ForeignTableRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ForeignTableRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_foreign_table_reloid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ForeignTableRelOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ForeignTableRelOidIndexId",
      "func_name" : "caql_basic_fn_116",
      "func_note" : "",
      "func_number" : "116",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_26",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_foreign_table"
   },
   "select * from pg_index where indexrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/index.c" : 3,
         "../../../..//src/backend/cdb/cdbpartindex.c" : 1,
         "../../../..//src/backend/commands/cluster.c" : 4,
         "../../../..//src/backend/commands/indexcmds.c" : 3,
         "../../../..//src/backend/commands/tablecmds.c" : 5,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (indexrelid)" : 1,
            "(oid) <- (indrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (indclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_117(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = INDEXRELID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = IndexRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(IndexRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_index_indexrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   IndexRelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "IndexRelidIndexId",
      "func_name" : "caql_basic_fn_117",
      "func_note" : "",
      "func_number" : "117",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_27",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 4,
      "syscacheid" : "INDEXRELID",
      "tablename" : "pg_index"
   },
   "select * from pg_index where indisclustered = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/cluster.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (indexrelid)" : 1,
            "(oid) <- (indrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (indclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_118(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = IndexRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(IndexRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_index_indisclustered,\n\t\t\t\tBTEqualStrategyNumber, F_BOOLEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_118",
      "func_note" : "",
      "func_number" : "118",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_27",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_index"
   },
   "select * from pg_index where indrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartindex.c" : 2,
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (indexrelid)" : 1,
            "(oid) <- (indrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (indclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_119(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = IndexRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(IndexRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   IndexIndrelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "IndexIndrelidIndexId",
      "func_name" : "caql_basic_fn_119",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_index(indrelid, ...) <IndexIndrelidIndexId>\n",
      "func_number" : "119",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_27",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_index"
   },
   "select * from pg_inherits where inhparent = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/optimizer/util/plancat.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (inhparent)" : 1,
            "(oid) <- (inhrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_120(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = InheritsRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(InheritsRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_inherits_inhparent,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_120",
      "func_note" : "",
      "func_number" : "120",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_28",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_inherits"
   },
   "select * from pg_inherits where inhrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 3,
         "../../../..//src/backend/commands/tablecmds.c" : 3,
         "../../../..//src/backend/parser/parse_func.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (inhparent)" : 1,
            "(oid) <- (inhrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_121(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = InheritsRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(InheritsRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_inherits_inhrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InheritsRelidSeqnoIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "InheritsRelidSeqnoIndexId",
      "func_name" : "caql_basic_fn_121",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_inherits(inhrelid, ...) <InheritsRelidSeqnoIndexId>\n",
      "func_number" : "121",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_28",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_inherits"
   },
   "select * from pg_inherits where inhrelid = :1 and inhseqno = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (inhparent)" : 1,
            "(oid) <- (inhrelid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_122(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = INHRELID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = InheritsRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(InheritsRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_inherits_inhrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_inherits_inhseqno,\n\t\t\t\tBTEqualStrategyNumber, F_INT4EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InheritsRelidSeqnoIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "InheritsRelidSeqnoIndexId",
      "func_name" : "caql_basic_fn_122",
      "func_note" : "",
      "func_number" : "122",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_28",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "INHRELID",
      "tablename" : "pg_inherits"
   },
   "select * from pg_language where lanname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 1,
         "../../../..//src/backend/commands/proclang.c" : 4,
         "../../../..//src/backend/utils/adt/acl.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (lanplcallfoid)" : 1,
            "(oid) <- (lanvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_123(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = LANGNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = LanguageRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(LanguageRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_language_lanname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   LanguageNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "LanguageNameIndexId",
      "func_name" : "caql_basic_fn_123",
      "func_note" : "",
      "func_number" : "123",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_29",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "LANGNAME",
      "tablename" : "pg_language"
   },
   "select * from pg_language where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 2,
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 1,
         "../../../..//src/backend/commands/proclang.c" : 1,
         "../../../..//src/backend/utils/adt/acl.c" : 3,
         "../../../..//src/backend/utils/fmgr/fmgr.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (lanplcallfoid)" : 1,
            "(oid) <- (lanvalidator)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_124(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = LANGOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = LanguageRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(LanguageRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   LanguageOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "LanguageOidIndexId",
      "func_name" : "caql_basic_fn_124",
      "func_note" : "",
      "func_number" : "124",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_29",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "LANGOID",
      "tablename" : "pg_language"
   },
   "select * from pg_largeobject where loid = :1" : {
      "cql" : "cql0",
      "files" : {
         "../../../..//src/backend/storage/large_object/inv_api.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_125(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = LargeObjectRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(LargeObjectRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_largeobject_loid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   LargeObjectLoidPagenoIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "LargeObjectLoidPagenoIndexId",
      "func_name" : "caql_basic_fn_125",
      "func_note" : "",
      "func_number" : "125",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_125(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tLargeObjectLoidPagenoIndexId: loid, pageno\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_largeobject_loid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_largeobject_pageno,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, LargeObjectRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_largeobject\",\n\t\t\t\t\t  \"loid, pageno\",\n\t\t\t\t\t  LargeObjectLoidPagenoIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_largeobject_loid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_largeobject_pageno,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT4OID);\n\t\n\t\tcaql_lockwell(pCtx, LargeObjectRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_largeobject\",\n\t\t\t\t\t  \"loid, pageno\",\n\t\t\t\t\t  LargeObjectLoidPagenoIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE/DELETE: no references\n\t\t   pg_largeobject is unrelated to any other table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_125 */\n",
      "iud_func_name" : "caql_iud_fn_125",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_largeobject"
   },
   "select * from pg_largeobject where loid = :1 ORDER_BY LargeObjectLoidPagenoIndexId" : {
      "cql" : "cql0",
      "files" : {
         "../../../..//src/backend/storage/large_object/inv_api.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_126(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = LargeObjectRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(LargeObjectRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_largeobject_loid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   LargeObjectLoidPagenoIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "LargeObjectLoidPagenoIndexId",
      "func_name" : "caql_basic_fn_126",
      "func_note" : "",
      "func_number" : "126",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_125",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_largeobject"
   },
   "select * from pg_largeobject where loid = :1 and pageno >= :2 ORDER_BY LargeObjectLoidPagenoIndexId" : {
      "cql" : "cql0",
      "files" : {
         "../../../..//src/backend/storage/large_object/inv_api.c" : 3
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_127(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = LargeObjectRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(LargeObjectRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_largeobject_loid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_largeobject_pageno,\n\t\t\t\tBTGreaterEqualStrategyNumber, F_INT4GE,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   LargeObjectLoidPagenoIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "LargeObjectLoidPagenoIndexId",
      "func_name" : "caql_basic_fn_127",
      "func_note" : "WHERE clause is not strict equality\n",
      "func_number" : "127",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_125",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_largeobject"
   },
   "select * from pg_namespace where nspname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (nspowner)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_128(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = NamespaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(NamespaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_namespace_nspname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   NamespaceNspnameNspdboidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "NamespaceNspnameNspdboidIndexId",
      "func_name" : "caql_basic_fn_128",
      "func_note" : "",
      "func_number" : "128",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_30",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_namespace"
   },
   "select * from pg_namespace where nspname = :1 and nspdboid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1,
         "../../../..//src/backend/catalog/pg_namespace.c" : 1,
         "../../../..//src/backend/commands/schemacmds.c" : 3
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (nspowner)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_129(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = NAMESPACENAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = NamespaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(NamespaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_namespace_nspname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_namespace_nspdboid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   NamespaceNspnameNspdboidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "NamespaceNspnameNspdboidIndexId",
      "func_name" : "caql_basic_fn_129",
      "func_note" : "",
      "func_number" : "129",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_30",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "NAMESPACENAME",
      "tablename" : "pg_namespace"
   },
   "select * from pg_namespace where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/catalog/namespace.c" : 1,
         "../../../..//src/backend/commands/schemacmds.c" : 2,
         "../../../..//src/backend/utils/adt/acl.c" : 3,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (nspowner)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_130(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = NAMESPACEOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = NamespaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(NamespaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   NamespaceOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "NamespaceOidIndexId",
      "func_name" : "caql_basic_fn_130",
      "func_note" : "",
      "func_number" : "130",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_30",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "NAMESPACEOID",
      "tablename" : "pg_namespace"
   },
   "select * from pg_opclass where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/index.c" : 1,
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/indexcmds.c" : 1,
         "../../../..//src/backend/commands/opclasscmds.c" : 5,
         "../../../..//src/backend/parser/parse_utilcmd.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 4
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (opcowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (opcnamespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_131(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = CLAOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorClassRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorClassRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OpclassOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OpclassOidIndexId",
      "func_name" : "caql_basic_fn_131",
      "func_note" : "",
      "func_number" : "131",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_31",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "syscacheid" : "CLAOID",
      "tablename" : "pg_opclass"
   },
   "select * from pg_opclass where opcamid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/indexcmds.c" : 1,
         "../../../..//src/backend/commands/opclasscmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (opcowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (opcnamespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_132(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorClassRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorClassRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_opclass_opcamid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OpclassAmNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OpclassAmNameNspIndexId",
      "func_name" : "caql_basic_fn_132",
      "func_note" : "",
      "func_number" : "132",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_31",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_opclass"
   },
   "select * from pg_opclass where opcamid = :1 and opcname = :2 and opcnamespace = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1,
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/indexcmds.c" : 1,
         "../../../..//src/backend/commands/opclasscmds.c" : 5
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (opcowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (opcnamespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_133(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = CLAAMNAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorClassRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorClassRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_opclass_opcamid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_opclass_opcname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_opclass_opcnamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OpclassAmNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OpclassAmNameNspIndexId",
      "func_name" : "caql_basic_fn_133",
      "func_note" : "",
      "func_number" : "133",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_31",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "syscacheid" : "CLAAMNAMENSP",
      "tablename" : "pg_opclass"
   },
   "select * from pg_opclass where opcintype = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (opcowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (opcnamespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_134(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = OperatorClassRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorClassRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_opclass_opcintype,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_134",
      "func_note" : "",
      "func_number" : "134",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_31",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_opclass"
   },
   "select * from pg_operator where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/catalog/pg_operator.c" : 3,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/opclasscmds.c" : 1,
         "../../../..//src/backend/commands/operatorcmds.c" : 3,
         "../../../..//src/backend/executor/nodeWindow.c" : 1,
         "../../../..//src/backend/parser/analyze.c" : 1,
         "../../../..//src/backend/parser/parse_oper.c" : 1,
         "../../../..//src/backend/utils/adt/regproc.c" : 2,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 2,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 10
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_135(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = OPEROID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OperatorOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OperatorOidIndexId",
      "func_name" : "caql_basic_fn_135",
      "func_note" : "",
      "func_number" : "135",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 4,
      "syscacheid" : "OPEROID",
      "tablename" : "pg_operator"
   },
   "select * from pg_operator where oprleft = :1 and oprright = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/lsyscache.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_136(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_operator_oprleft,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_operator_oprright,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_136",
      "func_note" : "",
      "func_number" : "136",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_operator"
   },
   "select * from pg_operator where oprname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/adt/regproc.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_137(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_operator_oprname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OperatorNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OperatorNameNspIndexId",
      "func_name" : "caql_basic_fn_137",
      "func_note" : "",
      "func_number" : "137",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_operator"
   },
   "select * from pg_operator where oprname = :1 ORDER_BY OperatorNameNspIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_138(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = OPERNAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_operator_oprname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OperatorNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OperatorNameNspIndexId",
      "func_name" : "caql_basic_fn_138",
      "func_note" : "Predicate does not match all index columns ( 1 != 4 ),\ncan only use syscache for SearchSysCacheList case\n",
      "func_number" : "138",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "OPERNAMENSP",
      "tablename" : "pg_operator"
   },
   "select * from pg_operator where oprname = :1 and oprleft = :2 and oprright = :3 ORDER_BY OperatorNameNspIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_139(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = OPERNAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_operator_oprname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_operator_oprleft,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_operator_oprright,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OperatorNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OperatorNameNspIndexId",
      "func_name" : "caql_basic_fn_139",
      "func_note" : "Predicate does not match all index columns ( 3 != 4 ),\ncan only use syscache for SearchSysCacheList case\n",
      "func_number" : "139",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "OPERNAMENSP",
      "tablename" : "pg_operator"
   },
   "select * from pg_operator where oprname = :1 and oprleft = :2 and oprright = :3 and oprnamespace = :4" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1,
         "../../../..//src/backend/catalog/pg_operator.c" : 1,
         "../../../..//src/backend/executor/nodeWindow.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (oprowner)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (oprnamespace)" : 1
         },
         "pg_operator" : {
            "(oid) <- (oprcom)" : 1,
            "(oid) <- (oprgtcmpop)" : 1,
            "(oid) <- (oprlsortop)" : 1,
            "(oid) <- (oprltcmpop)" : 1,
            "(oid) <- (oprnegate)" : 1,
            "(oid) <- (oprrsortop)" : 1
         },
         "pg_proc" : {
            "(oid) <- (oprcode)" : 1,
            "(oid) <- (oprjoin)" : 1,
            "(oid) <- (oprrest)" : 1
         },
         "pg_type" : {
            "(oid) <- (oprleft)" : 1,
            "(oid) <- (oprresult)" : 1,
            "(oid) <- (oprright)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_140(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 4))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = OPERNAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 4));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = OperatorRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(OperatorRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_operator_oprname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_operator_oprleft,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_operator_oprright,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[3],\n\t\t\t\tAnum_pg_operator_oprnamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[3]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   OperatorNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 4, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "OperatorNameNspIndexId",
      "func_name" : "caql_basic_fn_140",
      "func_note" : "",
      "func_number" : "140",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_32",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "OPERNAMENSP",
      "tablename" : "pg_operator"
   },
   "select * from pg_partition where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 2,
         "../../../..//src/backend/parser/analyze.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (parclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_141(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionOidIndexId",
      "func_name" : "caql_basic_fn_141",
      "func_note" : "",
      "func_number" : "141",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_33",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition"
   },
   "select * from pg_partition where parrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 5
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (parclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_142(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_parrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionParrelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionParrelidIndexId",
      "func_name" : "caql_basic_fn_142",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_partition(parrelid, ...) <PartitionParrelidIndexId>\n",
      "func_number" : "142",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_33",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_partition"
   },
   "select * from pg_partition where parrelid = :1 and parlevel = :2 and paristemplate = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartindex.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 4
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parrelid)" : 1
         },
         "pg_opclass" : {
            "(oid) <- (parclass) [vector]" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_143(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_parrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_partition_parlevel,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_partition_paristemplate,\n\t\t\t\tBTEqualStrategyNumber, F_BOOLEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionParrelidParlevelParistemplateIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionParrelidParlevelParistemplateIndexId",
      "func_name" : "caql_basic_fn_143",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_partition(parrelid, ...) <PartitionParrelidParlevelParistemplateIndexId>\n",
      "func_number" : "143",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_33",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_partition"
   },
   "select * from pg_partition_encoding where parencoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 2
      },
      "foreign_key_tables" : {
         "pg_partition" : {
            "(oid) <- (parencoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_144(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionEncodingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionEncodingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_encoding_parencoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionEncodingParencoidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionEncodingParencoidIndexId",
      "func_name" : "caql_basic_fn_144",
      "func_note" : "index pg_partition(oid) <PartitionOidIndexId> is a prefix of \n\tindex pg_partition_encoding(parencoid, ...) <PartitionEncodingParencoidIndexId>\n",
      "func_number" : "144",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_34",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_partition_encoding"
   },
   "select * from pg_partition_rule where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 2,
         "../../../..//src/backend/commands/tablecmds.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_145(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionRuleOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionRuleOidIndexId",
      "func_name" : "caql_basic_fn_145",
      "func_note" : "",
      "func_number" : "145",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where parchildrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 7,
         "../../../..//src/backend/parser/analyze.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_146(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_parchildrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionRuleParchildrelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionRuleParchildrelidIndexId",
      "func_name" : "caql_basic_fn_146",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_partition_rule(parchildrelid, ...) <PartitionRuleParchildrelidIndexId>\n",
      "func_number" : "146",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where paroid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_147(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_paroid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionRuleParoidParparentruleParruleordIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionRuleParoidParparentruleParruleordIndexId",
      "func_name" : "caql_basic_fn_147",
      "func_note" : "index pg_partition(oid) <PartitionOidIndexId> is a prefix of \n\tindex pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>\n",
      "func_number" : "147",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where paroid = :1 and parparentrule = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartindex.c" : 1,
         "../../../..//src/backend/cdb/cdbpartition.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_148(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_paroid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_partition_rule_parparentrule,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionRuleParoidParparentruleParruleordIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionRuleParoidParparentruleParruleordIndexId",
      "func_name" : "caql_basic_fn_148",
      "func_note" : "index pg_partition(oid) <PartitionOidIndexId> is a prefix of \n\tindex pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>\n",
      "func_number" : "148",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parname = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_149(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_paroid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_partition_rule_parparentrule,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_partition_rule_parname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_149",
      "func_note" : "",
      "func_number" : "149",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parruleord <= :3 ORDER_BY PartitionRuleParoidParparentruleParruleordIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_150(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_paroid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_partition_rule_parparentrule,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_partition_rule_parruleord,\n\t\t\t\tBTLessEqualStrategyNumber, F_INT2LE,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionRuleParoidParparentruleParruleordIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionRuleParoidParparentruleParruleordIndexId",
      "func_name" : "caql_basic_fn_150",
      "func_note" : "index pg_partition(oid) <PartitionOidIndexId> is a prefix of \n\tindex pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>\nWHERE clause is not strict equality\n",
      "func_number" : "150",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where paroid = :1 and parparentrule = :2 and parruleord = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_151(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_paroid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_partition_rule_parparentrule,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_partition_rule_parruleord,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PartitionRuleParoidParparentruleParruleordIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PartitionRuleParoidParparentruleParruleordIndexId",
      "func_name" : "caql_basic_fn_151",
      "func_note" : "index pg_partition(oid) <PartitionOidIndexId> is a prefix of \n\tindex pg_partition_rule(paroid, ...) <PartitionRuleParoidParparentruleParruleordIndexId>\n",
      "func_number" : "151",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_partition_rule where parparentrule = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/cdb/cdbpartition.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (parchildrelid)" : 1
         },
         "pg_partition" : {
            "(oid) <- (paroid)" : 1
         },
         "pg_partition_rule" : {
            "(oid) <- (parparentrule)" : 1
         },
         "pg_tablespace" : {
            "(oid) <- (partemplatespace)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_152(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = PartitionRuleRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PartitionRuleRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_partition_rule_parparentrule,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_152",
      "func_note" : "",
      "func_number" : "152",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_35",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_partition_rule"
   },
   "select * from pg_pltemplate where tmplname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/proclang.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_153(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = PLTemplateRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(PLTemplateRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_pltemplate_tmplname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   PLTemplateNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "PLTemplateNameIndexId",
      "func_name" : "caql_basic_fn_153",
      "func_note" : "",
      "func_number" : "153",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_153(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tPLTemplateNameIndexId: tmplname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_pltemplate_tmplname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, PLTemplateRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_pltemplate\",\n\t\t\t\t\t  \"tmplname\",\n\t\t\t\t\t  PLTemplateNameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_pltemplate_tmplname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, PLTemplateRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_pltemplate\",\n\t\t\t\t\t  \"tmplname\",\n\t\t\t\t\t  PLTemplateNameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE/DELETE: no references\n\t\t   pg_pltemplate is unrelated to any other table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_153 */\n",
      "iud_func_name" : "caql_iud_fn_153",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_pltemplate"
   },
   "select * from pg_proc where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/catalog/pg_aggregate.c" : 1,
         "../../../..//src/backend/catalog/pg_proc.c" : 3,
         "../../../..//src/backend/cdb/cdbdisp.c" : 1,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/commands/aggregatecmds.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 11,
         "../../../..//src/backend/commands/opclasscmds.c" : 1,
         "../../../..//src/backend/executor/functions.c" : 2,
         "../../../..//src/backend/executor/nodeAgg.c" : 1,
         "../../../..//src/backend/executor/nodeWindow.c" : 1,
         "../../../..//src/backend/optimizer/plan/planwindow.c" : 2,
         "../../../..//src/backend/optimizer/util/clauses.c" : 1,
         "../../../..//src/backend/parser/parse_coerce.c" : 1,
         "../../../..//src/backend/parser/parse_func.c" : 2,
         "../../../..//src/backend/utils/adt/acl.c" : 3,
         "../../../..//src/backend/utils/adt/regproc.c" : 2,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 10,
         "../../../..//src/backend/utils/fmgr/fmgr.c" : 2,
         "../../../..//src/backend/utils/fmgr/funcapi.c" : 2,
         "../../../..//src/backend/utils/mb/mbutils.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (proowner)" : 1
         },
         "pg_language" : {
            "(oid) <- (prolang)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (pronamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (proallargtypes) [vector]" : 1,
            "(oid) <- (proargtypes) [vector]" : 1,
            "(oid) <- (prorettype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_154(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = PROCOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ProcedureOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ProcedureOidIndexId",
      "func_name" : "caql_basic_fn_154",
      "func_note" : "",
      "func_number" : "154",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_36",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 10,
      "syscacheid" : "PROCOID",
      "tablename" : "pg_proc"
   },
   "select * from pg_proc where proname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/adt/regproc.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (proowner)" : 1
         },
         "pg_language" : {
            "(oid) <- (prolang)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (pronamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (proallargtypes) [vector]" : 1,
            "(oid) <- (proargtypes) [vector]" : 1,
            "(oid) <- (prorettype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_155(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_proc_proname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ProcedureNameArgsNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ProcedureNameArgsNspIndexId",
      "func_name" : "caql_basic_fn_155",
      "func_note" : "",
      "func_number" : "155",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_36",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_proc"
   },
   "select * from pg_proc where proname = :1 ORDER_BY ProcedureNameArgsNspIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (proowner)" : 1
         },
         "pg_language" : {
            "(oid) <- (prolang)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (pronamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (proallargtypes) [vector]" : 1,
            "(oid) <- (proargtypes) [vector]" : 1,
            "(oid) <- (prorettype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_156(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = PROCNAMEARGSNSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_proc_proname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ProcedureNameArgsNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ProcedureNameArgsNspIndexId",
      "func_name" : "caql_basic_fn_156",
      "func_note" : "Predicate does not match all index columns ( 1 != 3 ),\ncan only use syscache for SearchSysCacheList case\n",
      "func_number" : "156",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_36",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "PROCNAMEARGSNSP",
      "tablename" : "pg_proc"
   },
   "select * from pg_proc where proname = :1 and proargtypes = :2 and pronamespace = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_proc.c" : 1,
         "../../../..//src/backend/commands/aggregatecmds.c" : 1,
         "../../../..//src/backend/commands/functioncmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (proowner)" : 1
         },
         "pg_language" : {
            "(oid) <- (prolang)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (pronamespace)" : 1
         },
         "pg_type" : {
            "(oid) <- (proallargtypes) [vector]" : 1,
            "(oid) <- (proargtypes) [vector]" : 1,
            "(oid) <- (prorettype)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_157(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 3))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = PROCNAMEARGSNSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 3));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ProcedureRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcedureRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_proc_proname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_proc_proargtypes,\n\t\t\t\tBTEqualStrategyNumber, F_OIDVECTOREQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_proc_pronamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ProcedureNameArgsNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ProcedureNameArgsNspIndexId",
      "func_name" : "caql_basic_fn_157",
      "func_note" : "",
      "func_number" : "157",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_36",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "PROCNAMEARGSNSP",
      "tablename" : "pg_proc"
   },
   "select * from pg_proc_callback where profnoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_proc_callback.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (procallback)" : 1,
            "(oid) <- (profnoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_158(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ProcCallbackRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcCallbackRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_proc_callback_profnoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ProcCallbackProfnoidPromethodIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ProcCallbackProfnoidPromethodIndexId",
      "func_name" : "caql_basic_fn_158",
      "func_note" : "index pg_proc(oid) <ProcedureOidIndexId> is a prefix of \n\tindex pg_proc_callback(profnoid, ...) <ProcCallbackProfnoidPromethodIndexId>\n",
      "func_number" : "158",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_37",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_proc_callback"
   },
   "select * from pg_proc_callback where profnoid = :1 and promethod = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_proc_callback.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (procallback)" : 1,
            "(oid) <- (profnoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_159(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ProcCallbackRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ProcCallbackRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_proc_callback_profnoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_proc_callback_promethod,\n\t\t\t\tBTEqualStrategyNumber, F_CHAREQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ProcCallbackProfnoidPromethodIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ProcCallbackProfnoidPromethodIndexId",
      "func_name" : "caql_basic_fn_159",
      "func_note" : "",
      "func_number" : "159",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_37",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_proc_callback"
   },
   "select * from pg_resqueue where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/queue.c" : 1,
         "../../../..//src/backend/commands/user.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_160(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ResQueueRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ResQueueRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ResQueueOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ResQueueOidIndexId",
      "func_name" : "caql_basic_fn_160",
      "func_note" : "",
      "func_number" : "160",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_160(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tResQueueOidIndexId: oid\n\tResQueueRsqnameIndexId: rsqname\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ResQueueRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_resqueue\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ResQueueOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ResQueueRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_resqueue\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ResQueueOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_resqueue_rsqname,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ResQueueRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_resqueue\",\n\t\t\t\t\t  \"rsqname\",\n\t\t\t\t\t  ResQueueRsqnameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_resqueue_rsqname,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, ResQueueRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_resqueue\",\n\t\t\t\t\t  \"rsqname\",\n\t\t\t\t\t  ResQueueRsqnameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t/* \n\t\t  if deleting, pg_resqueue primary key may be referenced in:\n\t\t  pg_authid (rolresqueue) <- (oid)\n\t\t  pg_resqueuecapability (resqueueid) <- (oid) \n\t\t*/\n\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* INSERT/UPDATE: pg_resqueue does not have fk reference to any table */\n\t\t/* No Share Locks Acquired */\n\t}\n} /* end caql_iud_fn_160 */\n",
      "iud_func_name" : "caql_iud_fn_160",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_resqueue"
   },
   "select * from pg_resqueue where rsqname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/utils/resscheduler/resscheduler.c" : 1
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_161(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ResQueueRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ResQueueRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_resqueue_rsqname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ResQueueRsqnameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ResQueueRsqnameIndexId",
      "func_name" : "caql_basic_fn_161",
      "func_note" : "",
      "func_number" : "161",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_160",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_resqueue"
   },
   "select * from pg_resqueuecapability where resqueueid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/queue.c" : 1
      },
      "foreign_key_tables" : {
         "pg_resourcetype" : {
            "(restypid) <- (restypid)" : 1
         },
         "pg_resqueue" : {
            "(oid) <- (resqueueid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_162(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = ResQueueCapabilityRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(ResQueueCapabilityRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_resqueuecapability_resqueueid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   ResQueueCapabilityResqueueidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "ResQueueCapabilityResqueueidIndexId",
      "func_name" : "caql_basic_fn_162",
      "func_note" : "index pg_resqueue(oid) <ResQueueOidIndexId> is a prefix of \n\tindex pg_resqueuecapability(resqueueid, ...) <ResQueueCapabilityResqueueidIndexId>\n",
      "func_number" : "162",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_162(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tResQueueCapabilityOidIndexId: oid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ResQueueCapabilityRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_resqueuecapability\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ResQueueCapabilityOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, ResQueueCapabilityRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_resqueuecapability\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  ResQueueCapabilityOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_resourcetype (restypid) <- (restypid)\n\t\t  pg_resqueue (oid) <- (resqueueid) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_resqueuecapability_restypid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ResourceTypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_resourcetype\",\n\t\t\t\t\t\t  \"restypid\",\n\t\t\t\t\t\t  ResourceTypeRestypidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_resqueuecapability_restypid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ResourceTypeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_resourcetype\",\n\t\t\t\t\t\t  \"restypid\",\n\t\t\t\t\t\t  ResourceTypeRestypidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_resqueuecapability_resqueueid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ResQueueRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_resqueue\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ResQueueOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_resqueuecapability_resqueueid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ResQueueRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_resqueue\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ResQueueOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_162 */\n",
      "iud_func_name" : "caql_iud_fn_162",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_resqueuecapability"
   },
   "select * from pg_rewrite where ev_class = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/cache/relcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (ev_class)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_163(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = RewriteRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RewriteRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   RewriteRelRulenameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "RewriteRelRulenameIndexId",
      "func_name" : "caql_basic_fn_163",
      "func_note" : "",
      "func_number" : "163",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_163(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t2 unique indexes:\n\tRewriteOidIndexId: oid\n\tRewriteRelRulenameIndexId: ev_class, rulename\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, ObjectIdAttributeNumber,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, RewriteRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_rewrite\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  RewriteOidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, ObjectIdAttributeNumber,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, RewriteRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_rewrite\",\n\t\t\t\t\t  \"oid\",\n\t\t\t\t\t  RewriteOidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_rewrite_ev_class,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_rewrite_rulename,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, RewriteRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_rewrite\",\n\t\t\t\t\t  \"ev_class, rulename\",\n\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_rewrite_ev_class,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_rewrite_rulename,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, NAMEOID);\n\t\n\t\tcaql_lockwell(pCtx, RewriteRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_rewrite\",\n\t\t\t\t\t  \"ev_class, rulename\",\n\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_attribute (attrelid) <- (ev_class) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_163 */\n",
      "iud_func_name" : "caql_iud_fn_163",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_rewrite"
   },
   "select * from pg_rewrite where ev_class = :1 and rulename = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/rewrite/rewriteDefine.c" : 2,
         "../../../..//src/backend/rewrite/rewriteRemove.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (ev_class)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_164(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = RULERELNAME;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = RewriteRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RewriteRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_rewrite_rulename,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   RewriteRelRulenameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "RewriteRelRulenameIndexId",
      "func_name" : "caql_basic_fn_164",
      "func_note" : "",
      "func_number" : "164",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_163",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "syscacheid" : "RULERELNAME",
      "tablename" : "pg_rewrite"
   },
   "select * from pg_rewrite where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/rewrite/rewriteRemove.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (ev_class)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_165(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = RewriteRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RewriteRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   RewriteOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "RewriteOidIndexId",
      "func_name" : "caql_basic_fn_165",
      "func_note" : "",
      "func_number" : "165",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_163",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_rewrite"
   },
   "select * from pg_rewrite where rulename = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (ev_class)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_166(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = RewriteRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(RewriteRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_rewrite_rulename,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_166",
      "func_note" : "",
      "func_number" : "166",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_163",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_rewrite"
   },
   "select * from pg_shdepend where dbid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_shdepend.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         },
         "pg_database" : {
            "(oid) <- (dbid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_167(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = SharedDependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(SharedDependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_shdepend_dbid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   SharedDependDependerIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "SharedDependDependerIndexId",
      "func_name" : "caql_basic_fn_167",
      "func_note" : "index pg_database(oid) <DatabaseOidIndexId> is a prefix of \n\tindex pg_shdepend(dbid, ...) <SharedDependDependerIndexId>\n",
      "func_number" : "167",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_38",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_shdepend"
   },
   "select * from pg_shdepend where dbid = :1 and classid = :2 and objid = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_shdepend.c" : 3
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         },
         "pg_database" : {
            "(oid) <- (dbid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_168(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = SharedDependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(SharedDependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_shdepend_dbid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_shdepend_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_shdepend_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   SharedDependDependerIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "SharedDependDependerIndexId",
      "func_name" : "caql_basic_fn_168",
      "func_note" : "index pg_database(oid) <DatabaseOidIndexId> is a prefix of \n\tindex pg_shdepend(dbid, ...) <SharedDependDependerIndexId>\n",
      "func_number" : "168",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_38",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "tablename" : "pg_shdepend"
   },
   "select * from pg_shdepend where refclassid = :1 and refobjid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/pg_shdepend.c" : 4
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classid)" : 1,
            "(oid) <- (refclassid)" : 1
         },
         "pg_database" : {
            "(oid) <- (dbid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_169(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = SharedDependRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(SharedDependRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_shdepend_refclassid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_shdepend_refobjid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   SharedDependReferenceIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "SharedDependReferenceIndexId",
      "func_name" : "caql_basic_fn_169",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_shdepend(refclassid, ...) <SharedDependReferenceIndexId>\n",
      "func_number" : "169",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_38",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_shdepend"
   },
   "select * from pg_shdescription where objoid = :1 and classoid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (classoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_170(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = SharedDescriptionRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(SharedDescriptionRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_shdescription_objoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_shdescription_classoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   SharedDescriptionObjIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "SharedDescriptionObjIndexId",
      "func_name" : "caql_basic_fn_170",
      "func_note" : "",
      "func_number" : "170",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_39",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_shdescription"
   },
   "select * from pg_stat_last_operation where classid = :1 and objid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (stasysid)" : 1
         },
         "pg_class" : {
            "(oid) <- (classid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_171(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = StatLastOpRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatLastOpRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_statlastop_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_statlastop_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   StatLastOpClassidObjidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "StatLastOpClassidObjidIndexId",
      "func_name" : "caql_basic_fn_171",
      "func_note" : "",
      "func_number" : "171",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_40",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_stat_last_operation"
   },
   "select * from pg_stat_last_operation where classid = :1 and objid = :2 and staactionname = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (stasysid)" : 1
         },
         "pg_class" : {
            "(oid) <- (classid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_172(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = StatLastOpRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatLastOpRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_statlastop_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_statlastop_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_statlastop_staactionname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   StatLastOpClassidObjidStaactionnameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "StatLastOpClassidObjidStaactionnameIndexId",
      "func_name" : "caql_basic_fn_172",
      "func_note" : "",
      "func_number" : "172",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_40",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_stat_last_operation"
   },
   "select * from pg_stat_last_shoperation where classid = :1 and objid = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (stasysid)" : 1
         },
         "pg_class" : {
            "(oid) <- (classid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_173(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = StatLastShOpRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatLastShOpRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_statlastshop_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_statlastshop_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   StatLastShOpClassidObjidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "StatLastShOpClassidObjidIndexId",
      "func_name" : "caql_basic_fn_173",
      "func_note" : "",
      "func_number" : "173",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_41",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_stat_last_shoperation"
   },
   "select * from pg_stat_last_shoperation where classid = :1 and objid = :2 and staactionname = :3" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (stasysid)" : 1
         },
         "pg_class" : {
            "(oid) <- (classid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_174(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = StatLastShOpRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatLastShOpRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_statlastshop_classid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_statlastshop_objid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[2],\n\t\t\t\tAnum_pg_statlastshop_staactionname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[2]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   StatLastShOpClassidObjidStaactionnameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 3, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "StatLastShOpClassidObjidStaactionnameIndexId",
      "func_name" : "caql_basic_fn_174",
      "func_note" : "",
      "func_number" : "174",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_41",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_stat_last_shoperation"
   },
   "select * from pg_statistic where starelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (starelid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (staop1)" : 1,
            "(oid) <- (staop2)" : 1,
            "(oid) <- (staop3)" : 1,
            "(oid) <- (staop4)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_175(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = StatisticRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatisticRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_statistic_starelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   StatisticRelidAttnumIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "StatisticRelidAttnumIndexId",
      "func_name" : "caql_basic_fn_175",
      "func_note" : "",
      "func_number" : "175",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_175(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tStatisticRelidAttnumIndexId: starelid, staattnum\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_statistic_starelid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_statistic_staattnum,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, StatisticRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_statistic\",\n\t\t\t\t\t  \"starelid, staattnum\",\n\t\t\t\t\t  StatisticRelidAttnumIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_statistic_starelid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_statistic_staattnum,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, INT2OID);\n\t\n\t\tcaql_lockwell(pCtx, StatisticRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_statistic\",\n\t\t\t\t\t  \"starelid, staattnum\",\n\t\t\t\t\t  StatisticRelidAttnumIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_attribute (attrelid) <- (starelid)\n\t\t  pg_operator (oid) <- (staop1)\n\t\t  pg_operator (oid) <- (staop2)\n\t\t  pg_operator (oid) <- (staop3)\n\t\t  pg_operator (oid) <- (staop4) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\t{ d = 0; isnull = 0; }\n\t\t\tcaql_lockwell(pCtx, AttributeRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_attribute\",\n\t\t\t\t\t\t  \"attrelid\",\n\t\t\t\t\t\t  InvalidOid,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_statistic_staop1,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_statistic_staop1,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_statistic_staop2,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_statistic_staop2,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_statistic_staop3,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_statistic_staop3,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_statistic_staop4,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_statistic_staop4,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, OperatorRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_operator\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  OperatorOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_175 */\n",
      "iud_func_name" : "caql_iud_fn_175",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_statistic"
   },
   "select * from pg_statistic where starelid = :1 and staattnum = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/heap.c" : 1,
         "../../../..//src/backend/commands/analyze.c" : 1,
         "../../../..//src/backend/utils/adt/selfuncs.c" : 4,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 3
      },
      "foreign_key_tables" : {
         "pg_attribute" : {
            "(attrelid) <- (starelid)" : 1
         },
         "pg_operator" : {
            "(oid) <- (staop1)" : 1,
            "(oid) <- (staop2)" : 1,
            "(oid) <- (staop3)" : 1,
            "(oid) <- (staop4)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_176(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = STATRELATT;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = StatisticRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(StatisticRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_statistic_starelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_statistic_staattnum,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   StatisticRelidAttnumIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "StatisticRelidAttnumIndexId",
      "func_name" : "caql_basic_fn_176",
      "func_note" : "",
      "func_number" : "176",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_175",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "STATRELATT",
      "tablename" : "pg_statistic"
   },
   "select * from pg_tablespace" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/dbcommands.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (spcowner)" : 1
         },
         "pg_filespace" : {
            "(oid) <- (spcfsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_177(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = TableSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TableSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\t\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 0, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_177",
      "func_note" : "",
      "func_number" : "177",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_42",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_tablespace"
   },
   "select * from pg_tablespace where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 3,
         "../../../..//src/backend/commands/tablespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (spcowner)" : 1
         },
         "pg_filespace" : {
            "(oid) <- (spcfsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_178(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TableSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TableSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TablespaceOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TablespaceOidIndexId",
      "func_name" : "caql_basic_fn_178",
      "func_note" : "",
      "func_number" : "178",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_42",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_tablespace"
   },
   "select * from pg_tablespace where spcfsoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/filespace.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (spcowner)" : 1
         },
         "pg_filespace" : {
            "(oid) <- (spcfsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_179(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = TableSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TableSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_tablespace_spcfsoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_179",
      "func_note" : "",
      "func_number" : "179",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_42",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_tablespace"
   },
   "select * from pg_tablespace where spcname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/commands/tablespace.c" : 5
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (spcowner)" : 1
         },
         "pg_filespace" : {
            "(oid) <- (spcfsoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_180(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TableSpaceRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TableSpaceRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_tablespace_spcname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TablespaceNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TablespaceNameIndexId",
      "func_name" : "caql_basic_fn_180",
      "func_note" : "",
      "func_number" : "180",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_42",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 3,
      "tablename" : "pg_tablespace"
   },
   "select * from pg_trigger where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/commands/trigger.c" : 1,
         "../../../..//src/backend/utils/adt/ruleutils.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 6
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_181(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TriggerOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TriggerOidIndexId",
      "func_name" : "caql_basic_fn_181",
      "func_note" : "",
      "func_number" : "181",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_trigger"
   },
   "select * from pg_trigger where tgconstrname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/trigger.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_182(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_trigger_tgconstrname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TriggerConstrNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TriggerConstrNameIndexId",
      "func_name" : "caql_basic_fn_182",
      "func_note" : "",
      "func_number" : "182",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_trigger"
   },
   "select * from pg_trigger where tgconstrrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_183(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_trigger_tgconstrrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TriggerConstrRelidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TriggerConstrRelidIndexId",
      "func_name" : "caql_basic_fn_183",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_trigger(tgconstrrelid, ...) <TriggerConstrRelidIndexId>\n",
      "func_number" : "183",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_trigger"
   },
   "select * from pg_trigger where tgrelid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 1,
         "../../../..//src/backend/commands/trigger.c" : 2
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_184(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_trigger_tgrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TriggerRelidNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TriggerRelidNameIndexId",
      "func_name" : "caql_basic_fn_184",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_trigger(tgrelid, ...) <TriggerRelidNameIndexId>\n",
      "func_number" : "184",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_trigger"
   },
   "select * from pg_trigger where tgrelid = :1 ORDER_BY TriggerRelidNameIndexId" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/trigger.c" : 1
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_185(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_trigger_tgrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TriggerRelidNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TriggerRelidNameIndexId",
      "func_name" : "caql_basic_fn_185",
      "func_note" : "index pg_class(oid) <ClassOidIndexId> is a prefix of \n\tindex pg_trigger(tgrelid, ...) <TriggerRelidNameIndexId>\n",
      "func_number" : "185",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_trigger"
   },
   "select * from pg_trigger where tgrelid = :1 and tgname = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/comment.c" : 1,
         "../../../..//src/backend/commands/trigger.c" : 4
      },
      "foreign_key_tables" : {
         "pg_class" : {
            "(oid) <- (tgconstrrelid)" : 1,
            "(oid) <- (tgrelid)" : 1
         },
         "pg_proc" : {
            "(oid) <- (tgfoid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_186(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TriggerRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TriggerRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_trigger_tgrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_trigger_tgname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TriggerRelidNameIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TriggerRelidNameIndexId",
      "func_name" : "caql_basic_fn_186",
      "func_note" : "",
      "func_number" : "186",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_43",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 2,
      "tablename" : "pg_trigger"
   },
   "select * from pg_type where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/access/common/tupdesc.c" : 1,
         "../../../..//src/backend/catalog/aclchk.c" : 1,
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/catalog/index.c" : 2,
         "../../../..//src/backend/catalog/namespace.c" : 3,
         "../../../..//src/backend/catalog/pg_type.c" : 1,
         "../../../..//src/backend/cdb/cdbparquetstoragewrite.c" : 1,
         "../../../..//src/backend/cdb/cdbquerycontextdispatching.c" : 1,
         "../../../..//src/backend/cdb/motion/tupser.c" : 1,
         "../../../..//src/backend/commands/tablecmds.c" : 1,
         "../../../..//src/backend/commands/typecmds.c" : 11,
         "../../../..//src/backend/executor/spi.c" : 1,
         "../../../..//src/backend/parser/parse_node.c" : 1,
         "../../../..//src/backend/parser/parse_type.c" : 1,
         "../../../..//src/backend/utils/adt/format_type.c" : 2,
         "../../../..//src/backend/utils/adt/regproc.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 21,
         "../../../..//src/backend/utils/cache/typcache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (typowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (typrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (typnamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (typanalyze)" : 1,
            "(oid) <- (typinput)" : 1,
            "(oid) <- (typoutput)" : 1,
            "(oid) <- (typreceive)" : 1,
            "(oid) <- (typsend)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_187(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = TYPEOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TypeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TypeOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TypeOidIndexId",
      "func_name" : "caql_basic_fn_187",
      "func_note" : "",
      "func_number" : "187",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_44",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 8,
      "syscacheid" : "TYPEOID",
      "tablename" : "pg_type"
   },
   "select * from pg_type where typlen = :1 and typalign = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/tablecmds.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (typowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (typrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (typnamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (typanalyze)" : 1,
            "(oid) <- (typinput)" : 1,
            "(oid) <- (typoutput)" : 1,
            "(oid) <- (typreceive)" : 1,
            "(oid) <- (typsend)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_188(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\n\tpCtx->cq_relationId = TypeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_type_typlen,\n\t\t\t\tBTEqualStrategyNumber, F_INT2EQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_type_typalign,\n\t\t\t\tBTEqualStrategyNumber, F_CHAREQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   InvalidOid,\n\t\t\t\t   false,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_name" : "caql_basic_fn_188",
      "func_note" : "",
      "func_number" : "188",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_44",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_type"
   },
   "select * from pg_type where typname = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/utils/adt/regproc.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (typowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (typrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (typnamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (typanalyze)" : 1,
            "(oid) <- (typinput)" : 1,
            "(oid) <- (typoutput)" : 1,
            "(oid) <- (typreceive)" : 1,
            "(oid) <- (typsend)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_189(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TypeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_type_typname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TypeNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TypeNameNspIndexId",
      "func_name" : "caql_basic_fn_189",
      "func_note" : "",
      "func_number" : "189",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_44",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "tablename" : "pg_type"
   },
   "select * from pg_type where typname = :1 and typnamespace = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/namespace.c" : 2,
         "../../../..//src/backend/catalog/pg_type.c" : 2,
         "../../../..//src/backend/commands/typecmds.c" : 2,
         "../../../..//src/backend/parser/parse_type.c" : 1,
         "../../../..//src/backend/utils/cache/lsyscache.c" : 1
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (typowner)" : 1
         },
         "pg_class" : {
            "(oid) <- (typrelid)" : 1
         },
         "pg_namespace" : {
            "(oid) <- (typnamespace)" : 1
         },
         "pg_proc" : {
            "(oid) <- (typanalyze)" : 1,
            "(oid) <- (typinput)" : 1,
            "(oid) <- (typoutput)" : 1,
            "(oid) <- (typreceive)" : 1,
            "(oid) <- (typsend)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_190(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = TYPENAMENSP;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TypeRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_type_typname,\n\t\t\t\tBTEqualStrategyNumber, F_NAMEEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_type_typnamespace,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TypeNameNspIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TypeNameNspIndexId",
      "func_name" : "caql_basic_fn_190",
      "func_note" : "",
      "func_number" : "190",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_44",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "TYPENAMENSP",
      "tablename" : "pg_type"
   },
   "select * from pg_type_encoding where typid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/typecmds.c" : 2,
         "../../../..//src/backend/parser/analyze.c" : 1
      },
      "foreign_key_tables" : {
         "pg_type" : {
            "(oid) <- (typid)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_191(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\tAssert (!pCtx->cq_usesyscache);\n\tpCtx->cq_usesyscache = false; /* complain in debug, work in production */\n\t\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = TypeEncodingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(TypeEncodingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_type_encoding_typid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   TypeEncodingTypidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "TypeEncodingTypidIndexId",
      "func_name" : "caql_basic_fn_191",
      "func_note" : "",
      "func_number" : "191",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_45",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "tablename" : "pg_type_encoding"
   },
   "select * from pg_user_mapping where oid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/catalog/dependency.c" : 1,
         "../../../..//src/backend/commands/foreigncmds.c" : 2
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (umuser)" : 1
         },
         "pg_foreign_server" : {
            "(oid) <- (umserver)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_192(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = USERMAPPINGOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = UserMappingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(UserMappingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   UserMappingOidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "UserMappingOidIndexId",
      "func_name" : "caql_basic_fn_192",
      "func_note" : "",
      "func_number" : "192",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_46",
      "num_del_ops" : 1,
      "num_ins_ops" : 0,
      "num_upd_ops" : 1,
      "syscacheid" : "USERMAPPINGOID",
      "tablename" : "pg_user_mapping"
   },
   "select * from pg_user_mapping where umuser = :1 and umserver = :2" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/commands/foreigncmds.c" : 3
      },
      "foreign_key_tables" : {
         "pg_authid" : {
            "(oid) <- (umuser)" : 1
         },
         "pg_foreign_server" : {
            "(oid) <- (umserver)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_193(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 2))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = USERMAPPINGUSERSERVER;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 2));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = UserMappingRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(UserMappingRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_user_mapping_umuser,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\t\n\tScanKeyInit(&pCtx->cq_scanKeys[1],\n\t\t\t\tAnum_pg_user_mapping_umserver,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[1]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   UserMappingUserServerIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 2, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "UserMappingUserServerIndexId",
      "func_name" : "caql_basic_fn_193",
      "func_note" : "",
      "func_number" : "193",
      "indexes" : {},
      "iud_func" : null,
      "iud_func_name" : "caql_iud_fn_46",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "USERMAPPINGUSERSERVER",
      "tablename" : "pg_user_mapping"
   },
   "select * from pg_window where winfnoid = :1" : {
      "cql" : "cql",
      "files" : {
         "../../../..//src/backend/executor/nodeWindow.c" : 1,
         "../../../..//src/backend/optimizer/plan/planwindow.c" : 1,
         "../../../..//src/backend/parser/parse_clause.c" : 1,
         "../../../..//src/backend/parser/parse_func.c" : 1
      },
      "foreign_key_tables" : {
         "pg_proc" : {
            "(oid) <- (winfinfunc)" : 1,
            "(oid) <- (winfnoid)" : 1,
            "(oid) <- (winfunc)" : 1,
            "(oid) <- (winprefunc)" : 1
         }
      },
      "func" : "static\nSysScanDesc\ncaql_basic_fn_194(cqContext *pCtx, cq_list *pcql, bool bLockEntireTable)\n{\n\tSysScanDesc  scan;\n\t\n\tRelation\trel;\n\n\n\t/* always use the syscache unless the caller states otherwise */\n\tif (!pCtx->cq_setsyscache)\n\t{\n\t\tpCtx->cq_usesyscache = true;\n\t\n\t\t/* Normally, must match all columns of the index to use syscache,\n\t\t * except for case of SearchSysCacheList \n\t\t */\n\t\tif (!pCtx->cq_bCacheList && (pCtx->cq_NumKeys != 1))\n\t\t\tpCtx->cq_usesyscache = false;\n\t\n\t\t/* ARD-28, MPP-16119: can only use SnapshowNow with syscache */\n\t\tif (pCtx->cq_snapshot != SnapshotNow)\n\t\t{\n\t\t\t/* Complain in debug, but behave in production */\n\t\t\tAssert(!pCtx->cq_usesyscache);\n\t\n\t\t\tpCtx->cq_setsyscache = true;\n\t\t\tpCtx->cq_usesyscache = false;\n\t\t}\n\t}\n\t\n\tif (pCtx->cq_usesyscache)\n\t{\n\t\tpCtx->cq_cacheId      = WINFNOID;\n\t\n\t\t/* number of keys must match (unless a SearchSysCacheList ) */\n\t\tAssert(pCtx->cq_bCacheList || (pCtx->cq_NumKeys == 1));\n\t}\n\t\n\t/* else perform heap/index scan */\n\t/* always use the index (if possible) unless the caller states otherwise */\n\tif (!pCtx->cq_setidxOK)\n\t\tpCtx->cq_useidxOK = true;\n\n\tpCtx->cq_relationId = WindowRelationId;\n\n\tif (!pCtx->cq_externrel)\n\t{\n\t\t/* XXX XXX : NOTE: disable heap_open/lock for syscache \n\t\t\tonly if : no external lock mode or external relation\n\t\t*/\n\t\tif ((!pCtx->cq_setlockmode) &&\n\t\t\tpCtx->cq_usesyscache &&\n\t\t\t(AccessShareLock == pCtx->cq_lockmode))\n\t\t{\n\t\t\tpCtx->cq_externrel = true; /* pretend we have external relation */\n\t\t\tpCtx->cq_heap_rel  = InvalidRelation;\n\t\t\t/* \n\t\t\t\tpCtx->cq_tupdesc  = SysCache[pCtx->cq_cacheId]->cc_tupdesc;\n\t\t\t*/\n\t\t\n\t\t\treturn NULL; /* XXX XXX: return early - don't open heap */\n\t\t}\n\t\telse\n\n\t\t{\n\t\t\tpCtx->cq_heap_rel = heap_open(pCtx->cq_relationId, \n\t\t\t\t\t\t\t\t\t\t  pCtx->cq_lockmode);\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* make sure the supplied relation matches the caql */\n\t\tif (RelationIsValid(pCtx->cq_heap_rel))\n\t\t{\n\t\t\tAssert(WindowRelationId == \n\t\t\t\t   RelationGetRelid(pCtx->cq_heap_rel));\n\t\t\tpCtx->cq_tupdesc  = RelationGetDescr(pCtx->cq_heap_rel);\n\t\t}\n\n\t}\t\t\n\n\trel = pCtx->cq_heap_rel;\n\n\tif (pCtx->cq_usesyscache) return NULL; /* XXX XXX: don't init scan */\n\n\tScanKeyInit(&pCtx->cq_scanKeys[0],\n\t\t\t\tAnum_pg_window_winfnoid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t(pCtx->cq_datumKeys[0]));\n\n\tscan = systable_beginscan(rel,\n\t\t\t\t   WindowWinfnoidIndexId,\n\t\t\t\t   pCtx->cq_useidxOK,\n\t\t\t\t   pCtx->cq_snapshot, 1, pCtx->cq_scanKeys);\n\n\n\treturn (scan);\n}\n",
      "func_index" : "WindowWinfnoidIndexId",
      "func_name" : "caql_basic_fn_194",
      "func_note" : "",
      "func_number" : "194",
      "indexes" : {},
      "iud_func" : "\nstatic\nvoid caql_iud_fn_194(cqContext *pCtx, int is_iud, \n\t\t\t\t\t HeapTuple oldtup, HeapTuple newtup, bool dontWait,\n\t\t\t\t\t LOCKMODE pklockmode)\n{\n\tOid oldhash = 0;\n\tOid newhash = 0;\n\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\toldhash = 0;\n\t}\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tif (!pCtx->cq_setpklock)\n\t\t\tAssert(RelationIsValid(pCtx->cq_heap_rel));\n\t\n\t\tnewhash = 0;\n\t}\n\n\t/*\n\t1 unique index:\n\tWindowWinfnoidIndexId: winfnoid\n\t*/\n\tif (HeapTupleIsValid(newtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\tnewhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_window_winfnoid,  &isnull);\n\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, WindowRelationId, \n\t\t\t\t\t  pklockmode, newtup,\n\t\t\t\t\t  \"pg_window\",\n\t\t\t\t\t  \"winfnoid\",\n\t\t\t\t\t  WindowWinfnoidIndexId,\n\t\t\t\t\t  newhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\tif (HeapTupleIsValid(oldtup))\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\n\t\toldhash = 0;\n\t\n\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_window_winfnoid,  &isnull);\n\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\n\t\tcaql_lockwell(pCtx, WindowRelationId, \n\t\t\t\t\t  pklockmode, oldtup,\n\t\t\t\t\t  \"pg_window\",\n\t\t\t\t\t  \"winfnoid\",\n\t\t\t\t\t  WindowWinfnoidIndexId,\n\t\t\t\t\t  oldhash,\n\t\t\t\t\t  dontWait,\n\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t);\n\t}\n\n\n\t/* NOTE: don't get fk locks if only needed share locks on pk */\n\tif (pklockmode != AccessExclusiveLock)\n\t\treturn;\n\n\tif (!is_iud)\n\t{\n\t\t\n\t}\n\telse\n\t{\n\t\tdontWait = true; /* never wait for share locks on foreign keys */\n\t\t/* \n\t\t  if insert/update, check foreign keys against:\t\n\t\t  pg_proc (oid) <- (winfinfunc)\n\t\t  pg_proc (oid) <- (winfnoid)\n\t\t  pg_proc (oid) <- (winfunc)\n\t\t  pg_proc (oid) <- (winprefunc) \n\t\t*/\n\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_window_winfinfunc,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_window_winfinfunc,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_window_winfnoid,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_window_winfnoid,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_window_winfunc,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_window_winfunc,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(newtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\tnewhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, newtup, Anum_pg_window_winprefunc,  &isnull);\n\t\t\tnewhash = caql_pkhash(pCtx, newhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, newtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  newhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\t\tif (HeapTupleIsValid(oldtup))\n\t\t{\n\t\t\tDatum\t\td;\n\t\t\tbool\t\tisnull;\n\t\t\n\t\t\toldhash = 0;\n\t\t\n\t\t\td = caql_getattr_internal(pCtx, oldtup, Anum_pg_window_winprefunc,  &isnull);\n\t\t\toldhash = caql_pkhash(pCtx, oldhash, d, isnull, OIDOID);\n\t\t\n\t\t\tcaql_lockwell(pCtx, ProcedureRelationId, \n\t\t\t\t\t\t  AccessShareLock, oldtup,\n\t\t\t\t\t\t  \"pg_proc\",\n\t\t\t\t\t\t  \"oid\",\n\t\t\t\t\t\t  ProcedureOidIndexId,\n\t\t\t\t\t\t  oldhash,\n\t\t\t\t\t\t  dontWait,\n\t\t\t\t\t\t  false /* don't ignore invalid tuple */\n\t\t\t\t);\n\t\t}\n\n\t}\n} /* end caql_iud_fn_194 */\n",
      "iud_func_name" : "caql_iud_fn_194",
      "num_del_ops" : 0,
      "num_ins_ops" : 0,
      "num_upd_ops" : 0,
      "syscacheid" : "WINFNOID",
      "tablename" : "pg_window"
   }
}
