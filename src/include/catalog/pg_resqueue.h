/*-------------------------------------------------------------------------
 *
 * pg_resqueue.h
 *	  definition of the system "resource queue" relation (pg_resqueue).
 *
 *
 * Copyright (c) 2006-2010, Greenplum inc.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * $PostgreSQL$
 *
 * NOTES
 *	  the genbki.sh script reads this file and generates .bki
 *	  information from the DATA() statements.
 *
 *-------------------------------------------------------------------------
 */
#ifndef PG_RESQUEUE_H
#define PG_RESQUEUE_H


#include "catalog/genbki.h"

/* TIDYCAT_BEGINDEF

   CREATE TABLE pg_resqueue
   with (camelcase=ResQueue, shared=true, relid=6026, reltype_oid=9830, toast_oid=9820, toast_index=9821, toast_reltype=9822)
   (
   rsqname name, -- name of resource queue
   rsq_parent oid, -- oid of resource queue
   rsq_active_stats_cluster integer, -- active statement count limit
   rsq_memory_limit_cluster text, -- memory limit in cluster
   rsq_core_limit_cluster text, -- core limit in cluster
   rsq_resource_upper_factor real, -- resource upper limit in cluster
   rsq_allocation_policy text, -- query resource allocation policy
   rsq_vseg_resource_quota text, -- vsegment resource quota
   rsq_vseg_upper_limit integer, -- vsegment size upper limit
   rsq_creation_time timestamp with time zone, -- when the queue is created
   rsq_update_time timestamp with time zone, -- when the queue is updated ( create or alter )
   rsq_status text, -- the status of resource queue.
   );

   create unique index on pg_resqueue(oid) with (indexid=6027);
   create unique index on pg_resqueue(rsqname) with (indexid=6028);

   TIDYCAT_ENDDEF
*/

/* TIDYCAT_BEGIN_CODEGEN 

   WARNING: DO NOT MODIFY THE FOLLOWING SECTION: 
   Generated by ./tidycat.pl version 34
   on Thu Aug  7 17:27:40 2014
*/


/*
 TidyCat Comments for pg_resqueue:
  Table is shared, so catalog.c:IsSharedRelation is updated.
  Table has an Oid column.
  Table has static type (see pg_types.h).
  Table has TOASTable columns, and TOAST table has static type.
  Table has weird hack for timestamp column.
 
*/

/*
 * The CATALOG definition has to refer to the type of "rsq_creation_time" et al as
 * "timestamptz" (lower case) so that bootstrap mode recognizes it.  But
 * the C header files define this type as TimestampTz.	Since the field is
 * potentially-null and therefore cannot be accessed directly from C code,
 * there is no particular need for the C struct definition to show the
 * field type as TimestampTz --- instead we just make it Datum.
 */

#define timestamptz Datum

/* ----------------
 *		pg_resqueue definition.  cpp turns this into
 *		typedef struct FormData_pg_resqueue
 * ----------------
 */
#define ResQueueRelationId	6026

CATALOG(pg_resqueue,6026) BKI_SHARED_RELATION
{
	NameData	rsqname;					/* name of resource queue */
	Oid			rsq_parent;					/* oid of resource queue */
	int4		rsq_active_stats_cluster;	/* active statement count limit in cluster */
	text		rsq_memory_limit_cluster;	/* memory limit in cluster */
	text		rsq_core_limit_cluster;		/* core limit in cluster */
	float4		rsq_resource_upper_factor;	/* resource upper limit in cluster */
	text		rsq_allocation_policy;		/* query resource allocation policy */
	text		rsq_vseg_resource_quota;	/* vsegment resource quota */
	int4		rsq_vseg_upper_limit;		/* vsegment size upper limit */
	timestamptz	rsq_creation_time;			/* when the queue is created */
	timestamptz	rsq_update_time;			/* when the queue is updated ( create or alter ) */
	text		rsq_status;					/* the status of resource queue. */
} FormData_pg_resqueue;

#undef timestamptz


/* ----------------
 *		Form_pg_resqueue corresponds to a pointer to a tuple with
 *		the format of pg_resqueue relation.
 * ----------------
 */
typedef FormData_pg_resqueue *Form_pg_resqueue;


/* ----------------
 *		compiler constants for pg_resqueue
 * ----------------
 */
#define Natts_pg_resqueue							12
#define Anum_pg_resqueue_rsqname					1
#define Anum_pg_resqueue_rsq_parent					2
#define Anum_pg_resqueue_rsq_active_stats_cluster	3
#define Anum_pg_resqueue_rsq_memory_limit_cluster	4
#define Anum_pg_resqueue_rsq_core_limit_cluster		5
#define Anum_pg_resqueue_rsq_resource_upper_factor	6
#define Anum_pg_resqueue_rsq_allocation_policy		7
#define Anum_pg_resqueue_rsq_vseg_resource_quota	8
#define Anum_pg_resqueue_rsq_vseg_upper_limit		9
#define Anum_pg_resqueue_rsq_creation_time			10
#define Anum_pg_resqueue_rsq_update_time			11
#define Anum_pg_resqueue_rsq_status					12

/* TIDYCAT_END_CODEGEN */


/* Create initial default resource queue */
DATA(insert OID = 9800 ( "pg_root"    0      "-1"    "100%" "100%" 2 "even" _null_      _null_ _null_ _null_ "branch"));
DATA(insert OID = 6055 ( "pg_default" 9800   "100"   "50%"  "50%"  2 "even" "mem:128mb" -1     _null_ _null_ _null_));

#define DEFAULT_RESQUEUE_ACTIVESTATS			"100"
#define DEFAULT_RESQUEUE_UPPERFACTOR			"2"
#define DEFAULT_RESQUEUE_VSEG_UPPER_LIMIT		"-1"
#define DEFAULT_RESQUEUE_VSEG_UPPER_LIMIT_N		-1

#define MINIMUM_RESQUEUE_UPPER_FACTOR_LIMIT		"1"
#define MINIMUM_RESQUEUE_UPPER_FACTOR_LIMIT_N	1.0

#define DEFAULT_RESQUEUE_POLICY             	"even"
#define DEFAULT_RESQUEUE_SEG_QUOTA		    	"mem:128mb"

#define PG_RESQUEUE_COL_OID						"oid"
#define PG_RESQUEUE_COL_RSQNAME					"rsqname"
#define PG_RESQUEUE_COL_PARENT					"rsq_parent"
#define PG_RESQUEUE_COL_ACTIVE_STATS_CLUSTER	"rsq_active_stats_cluster"
#define PG_RESQUEUE_COL_MEMORY_LIMIT_CLUSTER	"rsq_memory_limit_cluster"
#define PG_RESQUEUE_COL_CORE_LIMIT_CLUSTER		"rsq_core_limit_cluster"
#define PG_RESQUEUE_COL_RESOURCE_UPPER_FACTOR	"rsq_resource_upper_factor"
#define PG_RESQUEUE_COL_ALLOCATION_POLICY		"rsq_allocation_policy"
#define PG_RESQUEUE_COL_VSEG_RESOURCE_QUOTA		"rsq_vseg_resource_quota"
#define PG_RESQUEUE_COL_VSEG_UPPER_LIMIT		"rsq_vseg_upper_limit"
#define PG_RESQUEUE_COL_CREATION_TIME			"rsq_creation_time"
#define PG_RESQUEUE_COL_UPDATE_TIME				"rsq_update_time"
#define PG_RESQUEUE_COL_STATUS					"rsq_status"

#define ROOTRESQUEUE_OID    9800
#define DEFAULTRESQUEUE_OID 6055

/*
  The flavors of resource types:

  required: user must specify this type during CREATE.  Every queue
  must always have this type entry in pg_resqueuecapability.  It is
  not required to have a default value.  It may or may not have an
  offvalue, depending on the "has disable" setting.

  optional (ie not required): user does not have to specify this type.
  If hasdefault is false, then no entry is required for
  pg_resqueuecapability.  If hasdefault is true, then CREATE will add
  the default entry to pg_resqueuecapability during CREATE.

  has disable: whether the resource type has an OFF switch, ie what is
  the WITHOUT behavior.  For a required type, if it can be disabled,
  then it must have an off value.  For an optional type, if it can be
  disabled, there are two options:

  1) if the optional type has a default value, then if must have an
     off value.  The off value can be the same as the default value.

  2) if the optional type does not have a default value, then the
     assumption is that it gets "shut off" by removing the
     pg_resqueuecapability entry.  The off value is ignored.  Which
     means if hasdefault is false, and required is false, then
     hasdisable must be true (because the CREATE statement won't add
     an entry for the type, so it is de facto disabled).

 */

/* MPP-6923: Resource Queue attribute flexibility */

/* TIDYCAT_BEGINDEF

   CREATE TABLE pg_resourcetype
   with (camelcase=ResourceType, shared=true, relid=6059, reltype_oid=6445)
   (
   resname name, -- name of resource type 
   restypid smallint, -- resource type id 
   resrequired boolean, -- if required, user must specify during CREATE
   reshasdefault boolean, -- create a default entry for optional type
   reshasdisable boolean, -- whether the type can be removed or shut off
   resdefaultsetting text,	-- default resource setting 
   resdisabledsetting text	-- value that turns it off 
	
   );

   create unique index on pg_resourcetype(oid) with (indexid=6061);
   create unique index on pg_resourcetype(restypid) with (indexid=6062);
   create unique index on pg_resourcetype(resname) with (indexid=6063);

   TIDYCAT_ENDDEF
*/
/* TIDYCAT_BEGIN_CODEGEN 

   WARNING: DO NOT MODIFY THE FOLLOWING SECTION: 
   Generated by ./tidycat.pl version 34
   on Thu Aug  7 17:27:40 2014
*/


/*
 TidyCat Comments for pg_resourcetype:
  Table is shared, so catalog.c:IsSharedRelation is updated.
  Table has an Oid column.
  Table has static type (see pg_types.h).
  Table has TOASTable columns, but NO TOAST table.

*/

/* ----------------
 *		pg_resourcetype definition.  cpp turns this into
 *		typedef struct FormData_pg_resourcetype
 * ----------------
 */
#define ResourceTypeRelationId	6059

CATALOG(pg_resourcetype,6059) BKI_SHARED_RELATION
{
	NameData	resname;			/* name of resource type  */
	int2		restypid;			/* resource type id  */
	bool		resrequired;		/* if required, user must specify during CREATE */
	bool		reshasdefault;		/* create a default entry for optional type */
	bool		reshasdisable;		/* whether the type can be removed or shut off */
	text		resdefaultsetting;	/* default resource setting  */
	text		resdisabledsetting;	/* value that turns it off  */
} FormData_pg_resourcetype;


/* ----------------
 *		Form_pg_resourcetype corresponds to a pointer to a tuple with
 *		the format of pg_resourcetype relation.
 * ----------------
 */
typedef FormData_pg_resourcetype *Form_pg_resourcetype;


/* ----------------
 *		compiler constants for pg_resourcetype
 * ----------------
 */
#define Natts_pg_resourcetype					7
#define Anum_pg_resourcetype_resname			1
#define Anum_pg_resourcetype_restypid			2
#define Anum_pg_resourcetype_resrequired		3
#define Anum_pg_resourcetype_reshasdefault		4
#define Anum_pg_resourcetype_reshasdisable		5
#define Anum_pg_resourcetype_resdefaultsetting	6
#define Anum_pg_resourcetype_resdisabledsetting	7


/* TIDYCAT_END_CODEGEN */

/* Create entry in pg_resourcetype for PRIORITY */
DATA(insert OID = 6454  ( active_statements 1 f t f -1  -1 ));
DATA(insert OID = 6455  ( parent 2 t f f -1  -1 ));
DATA(insert OID = 6456  ( memory_limit_cluster 3 t f f -1 -1));
DATA(insert OID = 6457  ( core_limit_cluster 4 t f f -1  -1 ));
DATA(insert OID = 6458  ( vsegment_resource_quota 5 f t f -1 -1 ));
DATA(insert OID = 6459  ( resource_upper_factor 6 f t f -1 -1 ));
/* 
   The first four entries of pg_resourcetype are special mappings for
   the original pg_resqueue columns.  The following table shows the
   correspondence between the original grammar, the pg_resqueue column
   name, and the WITH clause defnames.

  grammar           colname             orig_defname        new_defname 
 ------------------ -----------------   ---------------     -----------------
 "ACTIVE THRESHOLD" rsqcountlimit       activelimit         active_statements
 "COST THRESHOLD"   rsqcostlimit        costlimit           max_cost
 "IGNORE THRESHOLD" rsqignorecostlimit  ignorecostlimit     min_cost
 "OVERCOMMIT"       rsqovercommit       overcommit          cost_overcommit
*/

/* Note: the restypid is used by pg_dumpall.c to build CREATE statements */
#define PG_RESRCTYPE_ACTIVE_STATEMENTS	1	/* rsqcountlimit: count  */
#define PG_RESRCTYPE_MAX_COST			2	/* rsqcostlimit: max_cost */
#define PG_RESRCTYPE_MIN_COST			3	/* rsqignorecostlimit: min_cost */
#define PG_RESRCTYPE_COST_OVERCOMMIT	4	/* rsqovercommit: cost_overcommit*/
/* start of "pg_resourcetype" entries... */
#define PG_RESRCTYPE_PRIORITY			5	/* backoff.c: priority queue */
#define PG_RESRCTYPE_MEMORY_LIMIT		6	/* memquota.c: memory quota */

/* TIDYCAT_BEGINDEF

   CREATE TABLE pg_resqueuecapability
   with (camelcase=ResQueueCapability, shared=true, relid=6060, reltype_oid=6446)
   (
   resqueueid oid,		-- OID of the queue with this capability 
   restypid smallint,	-- resource type id (key to pg_resourcetype) 
   ressetting text		-- resource setting (opaque type) 
   );

   create unique index on pg_resqueuecapability(oid) with (indexid=6064);
   create index on pg_resqueuecapability(resqueueid) with (indexid=6065);
   create index on pg_resqueuecapability(restypid) with (indexid=6066);

   alter table pg_resqueuecapability add fk resqueueid on pg_resqueue(oid);
   alter table pg_resqueuecapability add fk restypid on pg_resourcetype(restypid);

   TIDYCAT_ENDDEF
*/
/* TIDYCAT_BEGIN_CODEGEN 

   WARNING: DO NOT MODIFY THE FOLLOWING SECTION: 
   Generated by ./tidycat.pl version 34
   on Thu Aug  7 17:27:40 2014
*/


/*
 TidyCat Comments for pg_resqueuecapability:
  Table is shared, so catalog.c:IsSharedRelation is updated.
  Table has an Oid column.
  Table has static type (see pg_types.h).
  Table has TOASTable columns, but NO TOAST table.

*/

/* ----------------
 *		pg_resqueuecapability definition.  cpp turns this into
 *		typedef struct FormData_pg_resqueuecapability
 * ----------------
 */
#define ResQueueCapabilityRelationId	6060

CATALOG(pg_resqueuecapability,6060) BKI_SHARED_RELATION
{
	Oid		resqueueid;	/* OID of the queue with this capability  */
	int2	restypid;	/* resource type id (key to pg_resourcetype)  */
	text	ressetting;	/* resource setting (opaque type)  */
} FormData_pg_resqueuecapability;


/* ----------------
 *		Form_pg_resqueuecapability corresponds to a pointer to a tuple with
 *		the format of pg_resqueuecapability relation.
 * ----------------
 */
typedef FormData_pg_resqueuecapability *Form_pg_resqueuecapability;


/* ----------------
 *		compiler constants for pg_resqueuecapability
 * ----------------
 */
#define Natts_pg_resqueuecapability				3
#define Anum_pg_resqueuecapability_resqueueid	1
#define Anum_pg_resqueuecapability_restypid		2
#define Anum_pg_resqueuecapability_ressetting	3


/* TIDYCAT_END_CODEGEN */


#endif   /* PG_RESQUEUE_H */
